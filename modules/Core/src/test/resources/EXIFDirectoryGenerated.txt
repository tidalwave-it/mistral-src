====

     Mistral - open source imaging engine
     Copyright (C) 2003-2012 by Tidalwave s.a.s.

    **********************************************************************************************************************

     Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
     the License. You may obtain a copy of the License at

         http://www.apache.org/licenses/LICENSE-2.0

     Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
     an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the
     specific language governing permissions and limitations under the License.

    **********************************************************************************************************************

     WWW: http://mistral.tidalwave.it
     SCM: https://bitbucket.org/tidalwave/mistral-src

====

package org.imajine.image.metadata;

import java.util.Map;
import java.util.HashMap;
import org.imajine.image.tools.Rational;

/* Automatically generated on Thu Jan 01 01:00:00 CET 1970*/

public class EXIFDirectoryGenerated extends Directory
  {
    private final static long serialVersionUID = 2056233055989339503L;
    private static Map<Integer, String> descriptionMapByTag = new HashMap<Integer, String>();
    public static enum NewSubFileType
       {
         IMAGE(0, "image"),
         REDUCED_RESOLUTION(1, "reduced resolution"),
         PAGE(2, "page"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private NewSubFileType (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static NewSubFileType fromInteger(int value)
           {
             if (value == (long)0) return IMAGE;
             if (value == (long)1) return REDUCED_RESOLUTION;
             if (value == (long)2) return PAGE;

             return _UNKNOWN;
           }
       }
    public boolean isNewSubFileTypeAvailable()
      {
        return containsTag(NEW_SUBFILE_TYPE);
      }

    public void setNewSubFileTypeAvailable (final boolean available)
      {
        if (available && !containsTag(NEW_SUBFILE_TYPE))
          {
            setNewSubFileType(null);
          }
        else if (!available)
          {
            removeTag(NEW_SUBFILE_TYPE);
          }
      }

    public NewSubFileType getNewSubFileType()
      {
        return (NewSubFileType)getObject(NEW_SUBFILE_TYPE);
      }

    public void setNewSubFileType (final NewSubFileType newSubFileType)
      {
        setObject(NEW_SUBFILE_TYPE, newSubFileType);
      }

    public static enum SubFileType
       {
         FULL_RESOLUTION(1, "full resolution"),
         REDUCED_RESOLUTION(2, "reduced resolution"),
         PAGE(3, "page"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private SubFileType (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static SubFileType fromInteger(int value)
           {
             if (value == (long)1) return FULL_RESOLUTION;
             if (value == (long)2) return REDUCED_RESOLUTION;
             if (value == (long)3) return PAGE;

             return _UNKNOWN;
           }
       }
    public boolean isSubFileTypeAvailable()
      {
        return containsTag(SUB_FILETYPE);
      }

    public void setSubFileTypeAvailable (final boolean available)
      {
        if (available && !containsTag(SUB_FILETYPE))
          {
            setSubFileType(null);
          }
        else if (!available)
          {
            removeTag(SUB_FILETYPE);
          }
      }

    public SubFileType getSubFileType()
      {
        return (SubFileType)getObject(SUB_FILETYPE);
      }

    public void setSubFileType (final SubFileType subFileType)
      {
        setObject(SUB_FILETYPE, subFileType);
      }

    public boolean isImageWidthAvailable()
      {
        return containsTag(IMAGE_WIDTH);
      }

    public void setImageWidthAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_WIDTH))
          {
            setImageWidth(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_WIDTH);
          }
      }

    public Long getImageWidth()
      {
        return (Long)getObject(IMAGE_WIDTH);
      }

    public void setImageWidth (final Long imageWidth)
      {
        setObject(IMAGE_WIDTH, imageWidth);
      }

    public boolean isImageLengthAvailable()
      {
        return containsTag(IMAGE_LENGTH);
      }

    public void setImageLengthAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_LENGTH))
          {
            setImageLength(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_LENGTH);
          }
      }

    public Long getImageLength()
      {
        return (Long)getObject(IMAGE_LENGTH);
      }

    public void setImageLength (final Long imageLength)
      {
        setObject(IMAGE_LENGTH, imageLength);
      }

    public boolean isBitsPerSampleAvailable()
      {
        return containsTag(BITS_PER_SAMPLE);
      }

    public void setBitsPerSampleAvailable (final boolean available)
      {
        if (available && !containsTag(BITS_PER_SAMPLE))
          {
            setBitsPerSample(null);
          }
        else if (!available)
          {
            removeTag(BITS_PER_SAMPLE);
          }
      }

    public int[] getBitsPerSample()
      {
        return (int[])getObject(BITS_PER_SAMPLE);
      }

    public void setBitsPerSample (final int[] bitsPerSample)
      {
        setObject(BITS_PER_SAMPLE, bitsPerSample);
      }

    public static enum Compression
       {
         UNCOMPRESSED(1, "uncompressed"),
         LZW(5, "lzw"),
         OJPEG(6, "OJPEG"),
         JPEG(7, "JPEG"),
         NEF_COMPRESSED(-30283, "NEF compressed"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private Compression (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static Compression fromInteger(int value)
           {
             if (value == (short)1) return UNCOMPRESSED;
             if (value == (short)5) return LZW;
             if (value == (short)6) return OJPEG;
             if (value == (short)7) return JPEG;
             if (value == (short)-30283) return NEF_COMPRESSED;

             return _UNKNOWN;
           }
       }
    public boolean isCompressionAvailable()
      {
        return containsTag(COMPRESSION);
      }

    public void setCompressionAvailable (final boolean available)
      {
        if (available && !containsTag(COMPRESSION))
          {
            setCompression(null);
          }
        else if (!available)
          {
            removeTag(COMPRESSION);
          }
      }

    public Compression getCompression()
      {
        return (Compression)getObject(COMPRESSION);
      }

    public void setCompression (final Compression compression)
      {
        setObject(COMPRESSION, compression);
      }

    public static enum PhotometricInterpretation
       {
         RGB(2, "rgb"),
         YCBCR(6, "YCbCr"),
         CFA(32803, "CFA"),
         LINEAR_RAW(34892, "Linear RAW"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private PhotometricInterpretation (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static PhotometricInterpretation fromInteger(int value)
           {
             if (value == (short)2) return RGB;
             if (value == (short)6) return YCBCR;
             if (value == (short)32803) return CFA;
             if (value == (short)34892) return LINEAR_RAW;

             return _UNKNOWN;
           }
       }
    public boolean isPhotometricInterpretationAvailable()
      {
        return containsTag(PHOTOMETRIC_INTERPRETATION);
      }

    public void setPhotometricInterpretationAvailable (final boolean available)
      {
        if (available && !containsTag(PHOTOMETRIC_INTERPRETATION))
          {
            setPhotometricInterpretation(null);
          }
        else if (!available)
          {
            removeTag(PHOTOMETRIC_INTERPRETATION);
          }
      }

    public PhotometricInterpretation getPhotometricInterpretation()
      {
        return (PhotometricInterpretation)getObject(PHOTOMETRIC_INTERPRETATION);
      }

    public void setPhotometricInterpretation (final PhotometricInterpretation photometricInterpretation)
      {
        setObject(PHOTOMETRIC_INTERPRETATION, photometricInterpretation);
      }

    public boolean isThresholdingAvailable()
      {
        return containsTag(THRESHOLDING);
      }

    public void setThresholdingAvailable (final boolean available)
      {
        if (available && !containsTag(THRESHOLDING))
          {
            setThresholding(null);
          }
        else if (!available)
          {
            removeTag(THRESHOLDING);
          }
      }

    public Integer getThresholding()
      {
        return (Integer)getObject(THRESHOLDING);
      }

    public void setThresholding (final Integer thresholding)
      {
        setObject(THRESHOLDING, thresholding);
      }

    public boolean isCellWidthAvailable()
      {
        return containsTag(CELL_WIDTH);
      }

    public void setCellWidthAvailable (final boolean available)
      {
        if (available && !containsTag(CELL_WIDTH))
          {
            setCellWidth(null);
          }
        else if (!available)
          {
            removeTag(CELL_WIDTH);
          }
      }

    public Integer getCellWidth()
      {
        return (Integer)getObject(CELL_WIDTH);
      }

    public void setCellWidth (final Integer cellWidth)
      {
        setObject(CELL_WIDTH, cellWidth);
      }

    public boolean isCellLengthAvailable()
      {
        return containsTag(CELL_LENGTH);
      }

    public void setCellLengthAvailable (final boolean available)
      {
        if (available && !containsTag(CELL_LENGTH))
          {
            setCellLength(null);
          }
        else if (!available)
          {
            removeTag(CELL_LENGTH);
          }
      }

    public Integer getCellLength()
      {
        return (Integer)getObject(CELL_LENGTH);
      }

    public void setCellLength (final Integer cellLength)
      {
        setObject(CELL_LENGTH, cellLength);
      }

    public boolean isFillOrderAvailable()
      {
        return containsTag(FILL_ORDER);
      }

    public void setFillOrderAvailable (final boolean available)
      {
        if (available && !containsTag(FILL_ORDER))
          {
            setFillOrder(null);
          }
        else if (!available)
          {
            removeTag(FILL_ORDER);
          }
      }

    public Integer getFillOrder()
      {
        return (Integer)getObject(FILL_ORDER);
      }

    public void setFillOrder (final Integer fillOrder)
      {
        setObject(FILL_ORDER, fillOrder);
      }

    public boolean isDocumentNameAvailable()
      {
        return containsTag(DOCUMENT_NAME);
      }

    public void setDocumentNameAvailable (final boolean available)
      {
        if (available && !containsTag(DOCUMENT_NAME))
          {
            setDocumentName(null);
          }
        else if (!available)
          {
            removeTag(DOCUMENT_NAME);
          }
      }

    public String getDocumentName()
      {
        return (String)getObject(DOCUMENT_NAME);
      }

    public void setDocumentName (final String documentName)
      {
        setObject(DOCUMENT_NAME, documentName);
      }

    public boolean isImageDescriptionAvailable()
      {
        return containsTag(IMAGE_DESCRIPTION);
      }

    public void setImageDescriptionAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_DESCRIPTION))
          {
            setImageDescription(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_DESCRIPTION);
          }
      }

    public String getImageDescription()
      {
        return (String)getObject(IMAGE_DESCRIPTION);
      }

    public void setImageDescription (final String imageDescription)
      {
        setObject(IMAGE_DESCRIPTION, imageDescription);
      }

    public boolean isMakeAvailable()
      {
        return containsTag(MAKE);
      }

    public void setMakeAvailable (final boolean available)
      {
        if (available && !containsTag(MAKE))
          {
            setMake(null);
          }
        else if (!available)
          {
            removeTag(MAKE);
          }
      }

    public String getMake()
      {
        return (String)getObject(MAKE);
      }

    public void setMake (final String make)
      {
        setObject(MAKE, make);
      }

    public boolean isModelAvailable()
      {
        return containsTag(MODEL);
      }

    public void setModelAvailable (final boolean available)
      {
        if (available && !containsTag(MODEL))
          {
            setModel(null);
          }
        else if (!available)
          {
            removeTag(MODEL);
          }
      }

    public String getModel()
      {
        return (String)getObject(MODEL);
      }

    public void setModel (final String model)
      {
        setObject(MODEL, model);
      }

    public boolean isStripOffsetsAvailable()
      {
        return containsTag(STRIP_OFFSETS);
      }

    public void setStripOffsetsAvailable (final boolean available)
      {
        if (available && !containsTag(STRIP_OFFSETS))
          {
            setStripOffsets(null);
          }
        else if (!available)
          {
            removeTag(STRIP_OFFSETS);
          }
      }

    public Integer getStripOffsets()
      {
        return (Integer)getObject(STRIP_OFFSETS);
      }

    public void setStripOffsets (final Integer stripOffsets)
      {
        setObject(STRIP_OFFSETS, stripOffsets);
      }

    public static enum Orientation
       {
         TOP_LEFT(1, "TOP LEFT"),
         TOP_RIGHT(2, "TOP RIGHT"),
         BOTTOM_RIGHT(3, "BOTTOM RIGHT"),
         BOTTOM_LEFT(4, "BOTTOM LEFT"),
         LEFT_TOP(5, "LEFT TOP"),
         RIGHT_TOP(6, "RIGHT TOP"),
         RIGHT_BOTTOM(7, "RIGHT BOTTOM"),
         LEFT_BOTTOM(8, "LEFT BOTTOM"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private Orientation (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static Orientation fromInteger(int value)
           {
             if (value == (short)1) return TOP_LEFT;
             if (value == (short)2) return TOP_RIGHT;
             if (value == (short)3) return BOTTOM_RIGHT;
             if (value == (short)4) return BOTTOM_LEFT;
             if (value == (short)5) return LEFT_TOP;
             if (value == (short)6) return RIGHT_TOP;
             if (value == (short)7) return RIGHT_BOTTOM;
             if (value == (short)8) return LEFT_BOTTOM;

             return _UNKNOWN;
           }
       }
    public boolean isOrientationAvailable()
      {
        return containsTag(ORIENTATION);
      }

    public void setOrientationAvailable (final boolean available)
      {
        if (available && !containsTag(ORIENTATION))
          {
            setOrientation(null);
          }
        else if (!available)
          {
            removeTag(ORIENTATION);
          }
      }

    public Orientation getOrientation()
      {
        return (Orientation)getObject(ORIENTATION);
      }

    public void setOrientation (final Orientation orientation)
      {
        setObject(ORIENTATION, orientation);
      }

    public boolean isSamplesPerPixelAvailable()
      {
        return containsTag(SAMPLES_PER_PIXEL);
      }

    public void setSamplesPerPixelAvailable (final boolean available)
      {
        if (available && !containsTag(SAMPLES_PER_PIXEL))
          {
            setSamplesPerPixel(null);
          }
        else if (!available)
          {
            removeTag(SAMPLES_PER_PIXEL);
          }
      }

    public Integer getSamplesPerPixel()
      {
        return (Integer)getObject(SAMPLES_PER_PIXEL);
      }

    public void setSamplesPerPixel (final Integer samplesPerPixel)
      {
        setObject(SAMPLES_PER_PIXEL, samplesPerPixel);
      }

    public boolean isRowsPerStripAvailable()
      {
        return containsTag(ROWS_PER_STRIP);
      }

    public void setRowsPerStripAvailable (final boolean available)
      {
        if (available && !containsTag(ROWS_PER_STRIP))
          {
            setRowsPerStrip(null);
          }
        else if (!available)
          {
            removeTag(ROWS_PER_STRIP);
          }
      }

    public Integer getRowsPerStrip()
      {
        return (Integer)getObject(ROWS_PER_STRIP);
      }

    public void setRowsPerStrip (final Integer rowsPerStrip)
      {
        setObject(ROWS_PER_STRIP, rowsPerStrip);
      }

    public boolean isStripByteCountsAvailable()
      {
        return containsTag(STRIP_BYTE_COUNTS);
      }

    public void setStripByteCountsAvailable (final boolean available)
      {
        if (available && !containsTag(STRIP_BYTE_COUNTS))
          {
            setStripByteCounts(null);
          }
        else if (!available)
          {
            removeTag(STRIP_BYTE_COUNTS);
          }
      }

    public Integer getStripByteCounts()
      {
        return (Integer)getObject(STRIP_BYTE_COUNTS);
      }

    public void setStripByteCounts (final Integer stripByteCounts)
      {
        setObject(STRIP_BYTE_COUNTS, stripByteCounts);
      }

    public boolean isMinSampleValueAvailable()
      {
        return containsTag(MIN_SAMPLE_VALUE);
      }

    public void setMinSampleValueAvailable (final boolean available)
      {
        if (available && !containsTag(MIN_SAMPLE_VALUE))
          {
            setMinSampleValue(null);
          }
        else if (!available)
          {
            removeTag(MIN_SAMPLE_VALUE);
          }
      }

    public int[] getMinSampleValue()
      {
        return (int[])getObject(MIN_SAMPLE_VALUE);
      }

    public void setMinSampleValue (final int[] minSampleValue)
      {
        setObject(MIN_SAMPLE_VALUE, minSampleValue);
      }

    public boolean isMaxSampleValueAvailable()
      {
        return containsTag(MAX_SAMPLE_VALUE);
      }

    public void setMaxSampleValueAvailable (final boolean available)
      {
        if (available && !containsTag(MAX_SAMPLE_VALUE))
          {
            setMaxSampleValue(null);
          }
        else if (!available)
          {
            removeTag(MAX_SAMPLE_VALUE);
          }
      }

    public int[] getMaxSampleValue()
      {
        return (int[])getObject(MAX_SAMPLE_VALUE);
      }

    public void setMaxSampleValue (final int[] maxSampleValue)
      {
        setObject(MAX_SAMPLE_VALUE, maxSampleValue);
      }

    public boolean isXResolutionAvailable()
      {
        return containsTag(X_RESOLUTION);
      }

    public void setXResolutionAvailable (final boolean available)
      {
        if (available && !containsTag(X_RESOLUTION))
          {
            setXResolution(null);
          }
        else if (!available)
          {
            removeTag(X_RESOLUTION);
          }
      }

    public Rational getXResolution()
      {
        return (Rational)getObject(X_RESOLUTION);
      }

    public void setXResolution (final Rational xResolution)
      {
        setObject(X_RESOLUTION, xResolution);
      }

    public boolean isYResolutionAvailable()
      {
        return containsTag(Y_RESOLUTION);
      }

    public void setYResolutionAvailable (final boolean available)
      {
        if (available && !containsTag(Y_RESOLUTION))
          {
            setYResolution(null);
          }
        else if (!available)
          {
            removeTag(Y_RESOLUTION);
          }
      }

    public Rational getYResolution()
      {
        return (Rational)getObject(Y_RESOLUTION);
      }

    public void setYResolution (final Rational yResolution)
      {
        setObject(Y_RESOLUTION, yResolution);
      }

    public static enum PlanarConfiguration
       {
         CHUNKY(1, "chunky"),
         PLANAR(2, "planar"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private PlanarConfiguration (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static PlanarConfiguration fromInteger(int value)
           {
             if (value == (short)1) return CHUNKY;
             if (value == (short)2) return PLANAR;

             return _UNKNOWN;
           }
       }
    public boolean isPlanarConfigurationAvailable()
      {
        return containsTag(PLANAR_CONFIGURATION);
      }

    public void setPlanarConfigurationAvailable (final boolean available)
      {
        if (available && !containsTag(PLANAR_CONFIGURATION))
          {
            setPlanarConfiguration(null);
          }
        else if (!available)
          {
            removeTag(PLANAR_CONFIGURATION);
          }
      }

    public PlanarConfiguration getPlanarConfiguration()
      {
        return (PlanarConfiguration)getObject(PLANAR_CONFIGURATION);
      }

    public void setPlanarConfiguration (final PlanarConfiguration planarConfiguration)
      {
        setObject(PLANAR_CONFIGURATION, planarConfiguration);
      }

    public boolean isPageNameAvailable()
      {
        return containsTag(PAGE_NAME);
      }

    public void setPageNameAvailable (final boolean available)
      {
        if (available && !containsTag(PAGE_NAME))
          {
            setPageName(null);
          }
        else if (!available)
          {
            removeTag(PAGE_NAME);
          }
      }

    public String getPageName()
      {
        return (String)getObject(PAGE_NAME);
      }

    public void setPageName (final String pageName)
      {
        setObject(PAGE_NAME, pageName);
      }

    public boolean isXPositionAvailable()
      {
        return containsTag(X_POSITION);
      }

    public void setXPositionAvailable (final boolean available)
      {
        if (available && !containsTag(X_POSITION))
          {
            setXPosition(null);
          }
        else if (!available)
          {
            removeTag(X_POSITION);
          }
      }

    public Rational getXPosition()
      {
        return (Rational)getObject(X_POSITION);
      }

    public void setXPosition (final Rational xPosition)
      {
        setObject(X_POSITION, xPosition);
      }

    public boolean isYPositionAvailable()
      {
        return containsTag(Y_POSITION);
      }

    public void setYPositionAvailable (final boolean available)
      {
        if (available && !containsTag(Y_POSITION))
          {
            setYPosition(null);
          }
        else if (!available)
          {
            removeTag(Y_POSITION);
          }
      }

    public Rational getYPosition()
      {
        return (Rational)getObject(Y_POSITION);
      }

    public void setYPosition (final Rational yPosition)
      {
        setObject(Y_POSITION, yPosition);
      }

    public boolean isFreeOffsetsAvailable()
      {
        return containsTag(FREE_OFFSETS);
      }

    public void setFreeOffsetsAvailable (final boolean available)
      {
        if (available && !containsTag(FREE_OFFSETS))
          {
            setFreeOffsets(null);
          }
        else if (!available)
          {
            removeTag(FREE_OFFSETS);
          }
      }

    public int[] getFreeOffsets()
      {
        return (int[])getObject(FREE_OFFSETS);
      }

    public void setFreeOffsets (final int[] freeOffsets)
      {
        setObject(FREE_OFFSETS, freeOffsets);
      }

    public boolean isFreeByteCountsAvailable()
      {
        return containsTag(FREE_BYTE_COUNTS);
      }

    public void setFreeByteCountsAvailable (final boolean available)
      {
        if (available && !containsTag(FREE_BYTE_COUNTS))
          {
            setFreeByteCounts(null);
          }
        else if (!available)
          {
            removeTag(FREE_BYTE_COUNTS);
          }
      }

    public int[] getFreeByteCounts()
      {
        return (int[])getObject(FREE_BYTE_COUNTS);
      }

    public void setFreeByteCounts (final int[] freeByteCounts)
      {
        setObject(FREE_BYTE_COUNTS, freeByteCounts);
      }

    public boolean isGrayResponseUnitAvailable()
      {
        return containsTag(GRAY_RESPONSE_UNIT);
      }

    public void setGrayResponseUnitAvailable (final boolean available)
      {
        if (available && !containsTag(GRAY_RESPONSE_UNIT))
          {
            setGrayResponseUnit(null);
          }
        else if (!available)
          {
            removeTag(GRAY_RESPONSE_UNIT);
          }
      }

    public Integer getGrayResponseUnit()
      {
        return (Integer)getObject(GRAY_RESPONSE_UNIT);
      }

    public void setGrayResponseUnit (final Integer grayResponseUnit)
      {
        setObject(GRAY_RESPONSE_UNIT, grayResponseUnit);
      }

    public boolean isGrayResponseCurveAvailable()
      {
        return containsTag(GRAY_RESPONSE_CURVE);
      }

    public void setGrayResponseCurveAvailable (final boolean available)
      {
        if (available && !containsTag(GRAY_RESPONSE_CURVE))
          {
            setGrayResponseCurve(null);
          }
        else if (!available)
          {
            removeTag(GRAY_RESPONSE_CURVE);
          }
      }

    public int[] getGrayResponseCurve()
      {
        return (int[])getObject(GRAY_RESPONSE_CURVE);
      }

    public void setGrayResponseCurve (final int[] grayResponseCurve)
      {
        setObject(GRAY_RESPONSE_CURVE, grayResponseCurve);
      }

    public boolean isGroup3OptionsAvailable()
      {
        return containsTag(GROUP_3_OPTIONS);
      }

    public void setGroup3OptionsAvailable (final boolean available)
      {
        if (available && !containsTag(GROUP_3_OPTIONS))
          {
            setGroup3Options(null);
          }
        else if (!available)
          {
            removeTag(GROUP_3_OPTIONS);
          }
      }

    public Long getGroup3Options()
      {
        return (Long)getObject(GROUP_3_OPTIONS);
      }

    public void setGroup3Options (final Long group3Options)
      {
        setObject(GROUP_3_OPTIONS, group3Options);
      }

    public boolean isGroup4OptionsAvailable()
      {
        return containsTag(GROUP_4_OPTIONS);
      }

    public void setGroup4OptionsAvailable (final boolean available)
      {
        if (available && !containsTag(GROUP_4_OPTIONS))
          {
            setGroup4Options(null);
          }
        else if (!available)
          {
            removeTag(GROUP_4_OPTIONS);
          }
      }

    public Long getGroup4Options()
      {
        return (Long)getObject(GROUP_4_OPTIONS);
      }

    public void setGroup4Options (final Long group4Options)
      {
        setObject(GROUP_4_OPTIONS, group4Options);
      }

    public static enum ResolutionUnit
       {
         INCHES(2, "inches"),
         CENTIMETERS(3, "centimeters"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private ResolutionUnit (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static ResolutionUnit fromInteger(int value)
           {
             if (value == (short)2) return INCHES;
             if (value == (short)3) return CENTIMETERS;

             return _UNKNOWN;
           }
       }
    public boolean isResolutionUnitAvailable()
      {
        return containsTag(RESOLUTION_UNIT);
      }

    public void setResolutionUnitAvailable (final boolean available)
      {
        if (available && !containsTag(RESOLUTION_UNIT))
          {
            setResolutionUnit(null);
          }
        else if (!available)
          {
            removeTag(RESOLUTION_UNIT);
          }
      }

    public ResolutionUnit getResolutionUnit()
      {
        return (ResolutionUnit)getObject(RESOLUTION_UNIT);
      }

    public void setResolutionUnit (final ResolutionUnit resolutionUnit)
      {
        setObject(RESOLUTION_UNIT, resolutionUnit);
      }

    public boolean isPageNumberAvailable()
      {
        return containsTag(PAGE_NUMBER);
      }

    public void setPageNumberAvailable (final boolean available)
      {
        if (available && !containsTag(PAGE_NUMBER))
          {
            setPageNumber(null);
          }
        else if (!available)
          {
            removeTag(PAGE_NUMBER);
          }
      }

    public int[] getPageNumber()
      {
        return (int[])getObject(PAGE_NUMBER);
      }

    public void setPageNumber (final int[] pageNumber)
      {
        setObject(PAGE_NUMBER, pageNumber);
      }

    public boolean isColorResponseUnitAvailable()
      {
        return containsTag(COLOR_RESPONSE_UNIT);
      }

    public void setColorResponseUnitAvailable (final boolean available)
      {
        if (available && !containsTag(COLOR_RESPONSE_UNIT))
          {
            setColorResponseUnit(null);
          }
        else if (!available)
          {
            removeTag(COLOR_RESPONSE_UNIT);
          }
      }

    public Integer getColorResponseUnit()
      {
        return (Integer)getObject(COLOR_RESPONSE_UNIT);
      }

    public void setColorResponseUnit (final Integer colorResponseUnit)
      {
        setObject(COLOR_RESPONSE_UNIT, colorResponseUnit);
      }

    public boolean isTransferFunctionAvailable()
      {
        return containsTag(TRANSFER_FUNCTION);
      }

    public void setTransferFunctionAvailable (final boolean available)
      {
        if (available && !containsTag(TRANSFER_FUNCTION))
          {
            setTransferFunction(null);
          }
        else if (!available)
          {
            removeTag(TRANSFER_FUNCTION);
          }
      }

    public int[] getTransferFunction()
      {
        return (int[])getObject(TRANSFER_FUNCTION);
      }

    public void setTransferFunction (final int[] transferFunction)
      {
        setObject(TRANSFER_FUNCTION, transferFunction);
      }

    public boolean isSoftwareAvailable()
      {
        return containsTag(SOFTWARE);
      }

    public void setSoftwareAvailable (final boolean available)
      {
        if (available && !containsTag(SOFTWARE))
          {
            setSoftware(null);
          }
        else if (!available)
          {
            removeTag(SOFTWARE);
          }
      }

    public String getSoftware()
      {
        return (String)getObject(SOFTWARE);
      }

    public void setSoftware (final String software)
      {
        setObject(SOFTWARE, software);
      }

    public boolean isDateTimeAvailable()
      {
        return containsTag(DATETIME);
      }

    public void setDateTimeAvailable (final boolean available)
      {
        if (available && !containsTag(DATETIME))
          {
            setDateTime(null);
          }
        else if (!available)
          {
            removeTag(DATETIME);
          }
      }

    public String getDateTime()
      {
        return (String)getObject(DATETIME);
      }

    public void setDateTime (final String dateTime)
      {
        setObject(DATETIME, dateTime);
      }

    public boolean isArtistAvailable()
      {
        return containsTag(ARTIST);
      }

    public void setArtistAvailable (final boolean available)
      {
        if (available && !containsTag(ARTIST))
          {
            setArtist(null);
          }
        else if (!available)
          {
            removeTag(ARTIST);
          }
      }

    public String getArtist()
      {
        return (String)getObject(ARTIST);
      }

    public void setArtist (final String artist)
      {
        setObject(ARTIST, artist);
      }

    public boolean isHostComputerAvailable()
      {
        return containsTag(HOST_COMPUTER);
      }

    public void setHostComputerAvailable (final boolean available)
      {
        if (available && !containsTag(HOST_COMPUTER))
          {
            setHostComputer(null);
          }
        else if (!available)
          {
            removeTag(HOST_COMPUTER);
          }
      }

    public String getHostComputer()
      {
        return (String)getObject(HOST_COMPUTER);
      }

    public void setHostComputer (final String hostComputer)
      {
        setObject(HOST_COMPUTER, hostComputer);
      }

    public boolean isPredictorAvailable()
      {
        return containsTag(PREDICTOR);
      }

    public void setPredictorAvailable (final boolean available)
      {
        if (available && !containsTag(PREDICTOR))
          {
            setPredictor(null);
          }
        else if (!available)
          {
            removeTag(PREDICTOR);
          }
      }

    public Integer getPredictor()
      {
        return (Integer)getObject(PREDICTOR);
      }

    public void setPredictor (final Integer predictor)
      {
        setObject(PREDICTOR, predictor);
      }

    public boolean isWhitePointAvailable()
      {
        return containsTag(WHITE_POINT);
      }

    public void setWhitePointAvailable (final boolean available)
      {
        if (available && !containsTag(WHITE_POINT))
          {
            setWhitePoint(null);
          }
        else if (!available)
          {
            removeTag(WHITE_POINT);
          }
      }

    public Rational[] getWhitePoint()
      {
        return (Rational[])getObject(WHITE_POINT);
      }

    public void setWhitePoint (final Rational[] whitePoint)
      {
        setObject(WHITE_POINT, whitePoint);
      }

    public boolean isPrimaryChromaticitiesAvailable()
      {
        return containsTag(PRIMARY_CHROMATICITIES);
      }

    public void setPrimaryChromaticitiesAvailable (final boolean available)
      {
        if (available && !containsTag(PRIMARY_CHROMATICITIES))
          {
            setPrimaryChromaticities(null);
          }
        else if (!available)
          {
            removeTag(PRIMARY_CHROMATICITIES);
          }
      }

    public Rational[] getPrimaryChromaticities()
      {
        return (Rational[])getObject(PRIMARY_CHROMATICITIES);
      }

    public void setPrimaryChromaticities (final Rational[] primaryChromaticities)
      {
        setObject(PRIMARY_CHROMATICITIES, primaryChromaticities);
      }

    public boolean isTileWidthAvailable()
      {
        return containsTag(TILE_WIDTH);
      }

    public void setTileWidthAvailable (final boolean available)
      {
        if (available && !containsTag(TILE_WIDTH))
          {
            setTileWidth(null);
          }
        else if (!available)
          {
            removeTag(TILE_WIDTH);
          }
      }

    public Integer getTileWidth()
      {
        return (Integer)getObject(TILE_WIDTH);
      }

    public void setTileWidth (final Integer tileWidth)
      {
        setObject(TILE_WIDTH, tileWidth);
      }

    public boolean isTileLengthAvailable()
      {
        return containsTag(TILE_LENGTH);
      }

    public void setTileLengthAvailable (final boolean available)
      {
        if (available && !containsTag(TILE_LENGTH))
          {
            setTileLength(null);
          }
        else if (!available)
          {
            removeTag(TILE_LENGTH);
          }
      }

    public Integer getTileLength()
      {
        return (Integer)getObject(TILE_LENGTH);
      }

    public void setTileLength (final Integer tileLength)
      {
        setObject(TILE_LENGTH, tileLength);
      }

    public boolean isTileOffsetsAvailable()
      {
        return containsTag(TILE_OFFSETS);
      }

    public void setTileOffsetsAvailable (final boolean available)
      {
        if (available && !containsTag(TILE_OFFSETS))
          {
            setTileOffsets(null);
          }
        else if (!available)
          {
            removeTag(TILE_OFFSETS);
          }
      }

    public int[] getTileOffsets()
      {
        return (int[])getObject(TILE_OFFSETS);
      }

    public void setTileOffsets (final int[] tileOffsets)
      {
        setObject(TILE_OFFSETS, tileOffsets);
      }

    public boolean isTileByteCountsAvailable()
      {
        return containsTag(TILE_BYTE_COUNTS);
      }

    public void setTileByteCountsAvailable (final boolean available)
      {
        if (available && !containsTag(TILE_BYTE_COUNTS))
          {
            setTileByteCounts(null);
          }
        else if (!available)
          {
            removeTag(TILE_BYTE_COUNTS);
          }
      }

    public int[] getTileByteCounts()
      {
        return (int[])getObject(TILE_BYTE_COUNTS);
      }

    public void setTileByteCounts (final int[] tileByteCounts)
      {
        setObject(TILE_BYTE_COUNTS, tileByteCounts);
      }

    public boolean isBadFaxLinesAvailable()
      {
        return containsTag(BAD_FAX_LINES);
      }

    public void setBadFaxLinesAvailable (final boolean available)
      {
        if (available && !containsTag(BAD_FAX_LINES))
          {
            setBadFaxLines(null);
          }
        else if (!available)
          {
            removeTag(BAD_FAX_LINES);
          }
      }

    public Long getBadFaxLines()
      {
        return (Long)getObject(BAD_FAX_LINES);
      }

    public void setBadFaxLines (final Long badFaxLines)
      {
        setObject(BAD_FAX_LINES, badFaxLines);
      }

    public boolean isCleanFaxDataAvailable()
      {
        return containsTag(CLEAN_FAX_DATA);
      }

    public void setCleanFaxDataAvailable (final boolean available)
      {
        if (available && !containsTag(CLEAN_FAX_DATA))
          {
            setCleanFaxData(null);
          }
        else if (!available)
          {
            removeTag(CLEAN_FAX_DATA);
          }
      }

    public Integer getCleanFaxData()
      {
        return (Integer)getObject(CLEAN_FAX_DATA);
      }

    public void setCleanFaxData (final Integer cleanFaxData)
      {
        setObject(CLEAN_FAX_DATA, cleanFaxData);
      }

    public boolean isConsecutiveBadFaxLinesAvailable()
      {
        return containsTag(CONSECUTIVE_BAD_FAX_LINES);
      }

    public void setConsecutiveBadFaxLinesAvailable (final boolean available)
      {
        if (available && !containsTag(CONSECUTIVE_BAD_FAX_LINES))
          {
            setConsecutiveBadFaxLines(null);
          }
        else if (!available)
          {
            removeTag(CONSECUTIVE_BAD_FAX_LINES);
          }
      }

    public Long getConsecutiveBadFaxLines()
      {
        return (Long)getObject(CONSECUTIVE_BAD_FAX_LINES);
      }

    public void setConsecutiveBadFaxLines (final Long consecutiveBadFaxLines)
      {
        setObject(CONSECUTIVE_BAD_FAX_LINES, consecutiveBadFaxLines);
      }

    public boolean isSubIFDsAvailable()
      {
        return containsTag(SUB_IFDS);
      }

    public void setSubIFDsAvailable (final boolean available)
      {
        if (available && !containsTag(SUB_IFDS))
          {
            setSubIFDs(null);
          }
        else if (!available)
          {
            removeTag(SUB_IFDS);
          }
      }

    public int[] getSubIFDs()
      {
        return (int[])getObject(SUB_IFDS);
      }

    public void setSubIFDs (final int[] subIFDs)
      {
        setObject(SUB_IFDS, subIFDs);
      }

    public boolean isInkSetAvailable()
      {
        return containsTag(INK_SET);
      }

    public void setInkSetAvailable (final boolean available)
      {
        if (available && !containsTag(INK_SET))
          {
            setInkSet(null);
          }
        else if (!available)
          {
            removeTag(INK_SET);
          }
      }

    public Integer getInkSet()
      {
        return (Integer)getObject(INK_SET);
      }

    public void setInkSet (final Integer inkSet)
      {
        setObject(INK_SET, inkSet);
      }

    public boolean isInkNamesAvailable()
      {
        return containsTag(INK_NAMES);
      }

    public void setInkNamesAvailable (final boolean available)
      {
        if (available && !containsTag(INK_NAMES))
          {
            setInkNames(null);
          }
        else if (!available)
          {
            removeTag(INK_NAMES);
          }
      }

    public String getInkNames()
      {
        return (String)getObject(INK_NAMES);
      }

    public void setInkNames (final String inkNames)
      {
        setObject(INK_NAMES, inkNames);
      }

    public boolean isNumberOfInksAvailable()
      {
        return containsTag(NUMBER_OF_INKS);
      }

    public void setNumberOfInksAvailable (final boolean available)
      {
        if (available && !containsTag(NUMBER_OF_INKS))
          {
            setNumberOfInks(null);
          }
        else if (!available)
          {
            removeTag(NUMBER_OF_INKS);
          }
      }

    public Integer getNumberOfInks()
      {
        return (Integer)getObject(NUMBER_OF_INKS);
      }

    public void setNumberOfInks (final Integer numberOfInks)
      {
        setObject(NUMBER_OF_INKS, numberOfInks);
      }

    public boolean isDotRangeAvailable()
      {
        return containsTag(DOT_RANGE);
      }

    public void setDotRangeAvailable (final boolean available)
      {
        if (available && !containsTag(DOT_RANGE))
          {
            setDotRange(null);
          }
        else if (!available)
          {
            removeTag(DOT_RANGE);
          }
      }

    public byte[] getDotRange()
      {
        return (byte[])getObject(DOT_RANGE);
      }

    public void setDotRange (final byte[] dotRange)
      {
        setObject(DOT_RANGE, dotRange);
      }

    public boolean isTargetPrinterAvailable()
      {
        return containsTag(TARGET_PRINTER);
      }

    public void setTargetPrinterAvailable (final boolean available)
      {
        if (available && !containsTag(TARGET_PRINTER))
          {
            setTargetPrinter(null);
          }
        else if (!available)
          {
            removeTag(TARGET_PRINTER);
          }
      }

    public String getTargetPrinter()
      {
        return (String)getObject(TARGET_PRINTER);
      }

    public void setTargetPrinter (final String targetPrinter)
      {
        setObject(TARGET_PRINTER, targetPrinter);
      }

    public boolean isExtraSamplesAvailable()
      {
        return containsTag(EXTRA_SAMPLES);
      }

    public void setExtraSamplesAvailable (final boolean available)
      {
        if (available && !containsTag(EXTRA_SAMPLES))
          {
            setExtraSamples(null);
          }
        else if (!available)
          {
            removeTag(EXTRA_SAMPLES);
          }
      }

    public byte[] getExtraSamples()
      {
        return (byte[])getObject(EXTRA_SAMPLES);
      }

    public void setExtraSamples (final byte[] extraSamples)
      {
        setObject(EXTRA_SAMPLES, extraSamples);
      }

    public boolean isSampleFormatAvailable()
      {
        return containsTag(SAMPLE_FORMAT);
      }

    public void setSampleFormatAvailable (final boolean available)
      {
        if (available && !containsTag(SAMPLE_FORMAT))
          {
            setSampleFormat(null);
          }
        else if (!available)
          {
            removeTag(SAMPLE_FORMAT);
          }
      }

    public int[] getSampleFormat()
      {
        return (int[])getObject(SAMPLE_FORMAT);
      }

    public void setSampleFormat (final int[] sampleFormat)
      {
        setObject(SAMPLE_FORMAT, sampleFormat);
      }

    public boolean isTransferRangeAvailable()
      {
        return containsTag(TRANSFER_RANGE);
      }

    public void setTransferRangeAvailable (final boolean available)
      {
        if (available && !containsTag(TRANSFER_RANGE))
          {
            setTransferRange(null);
          }
        else if (!available)
          {
            removeTag(TRANSFER_RANGE);
          }
      }

    public int[] getTransferRange()
      {
        return (int[])getObject(TRANSFER_RANGE);
      }

    public void setTransferRange (final int[] transferRange)
      {
        setObject(TRANSFER_RANGE, transferRange);
      }

    public boolean isClipPathAvailable()
      {
        return containsTag(CLIP_PATH);
      }

    public void setClipPathAvailable (final boolean available)
      {
        if (available && !containsTag(CLIP_PATH))
          {
            setClipPath(null);
          }
        else if (!available)
          {
            removeTag(CLIP_PATH);
          }
      }

    public byte[] getClipPath()
      {
        return (byte[])getObject(CLIP_PATH);
      }

    public void setClipPath (final byte[] clipPath)
      {
        setObject(CLIP_PATH, clipPath);
      }

    public boolean isXClipPathUnitsAvailable()
      {
        return containsTag(X_CLIP_PATH_UNITS);
      }

    public void setXClipPathUnitsAvailable (final boolean available)
      {
        if (available && !containsTag(X_CLIP_PATH_UNITS))
          {
            setXClipPathUnits(null);
          }
        else if (!available)
          {
            removeTag(X_CLIP_PATH_UNITS);
          }
      }

    public Long getXClipPathUnits()
      {
        return (Long)getObject(X_CLIP_PATH_UNITS);
      }

    public void setXClipPathUnits (final Long xClipPathUnits)
      {
        setObject(X_CLIP_PATH_UNITS, xClipPathUnits);
      }

    public boolean isYClipPathUnitsAvailable()
      {
        return containsTag(Y_CLIP_PATH_UNITS);
      }

    public void setYClipPathUnitsAvailable (final boolean available)
      {
        if (available && !containsTag(Y_CLIP_PATH_UNITS))
          {
            setYClipPathUnits(null);
          }
        else if (!available)
          {
            removeTag(Y_CLIP_PATH_UNITS);
          }
      }

    public Long getYClipPathUnits()
      {
        return (Long)getObject(Y_CLIP_PATH_UNITS);
      }

    public void setYClipPathUnits (final Long yClipPathUnits)
      {
        setObject(Y_CLIP_PATH_UNITS, yClipPathUnits);
      }

    public boolean isIndexedAvailable()
      {
        return containsTag(INDEXED);
      }

    public void setIndexedAvailable (final boolean available)
      {
        if (available && !containsTag(INDEXED))
          {
            setIndexed(null);
          }
        else if (!available)
          {
            removeTag(INDEXED);
          }
      }

    public Integer getIndexed()
      {
        return (Integer)getObject(INDEXED);
      }

    public void setIndexed (final Integer indexed)
      {
        setObject(INDEXED, indexed);
      }

    public boolean isJPEGTablesAvailable()
      {
        return containsTag(JPEG_TABLES);
      }

    public void setJPEGTablesAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_TABLES))
          {
            setJPEGTables(null);
          }
        else if (!available)
          {
            removeTag(JPEG_TABLES);
          }
      }

    public byte[] getJPEGTables()
      {
        return (byte[])getObject(JPEG_TABLES);
      }

    public void setJPEGTables (final byte[] jPEGTables)
      {
        setObject(JPEG_TABLES, jPEGTables);
      }

    public boolean isOPIProxyAvailable()
      {
        return containsTag(OPI_PROXY);
      }

    public void setOPIProxyAvailable (final boolean available)
      {
        if (available && !containsTag(OPI_PROXY))
          {
            setOPIProxy(null);
          }
        else if (!available)
          {
            removeTag(OPI_PROXY);
          }
      }

    public Integer getOPIProxy()
      {
        return (Integer)getObject(OPI_PROXY);
      }

    public void setOPIProxy (final Integer oPIProxy)
      {
        setObject(OPI_PROXY, oPIProxy);
      }

    public boolean isJPEGProcAvailable()
      {
        return containsTag(JPEG_PROC);
      }

    public void setJPEGProcAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_PROC))
          {
            setJPEGProc(null);
          }
        else if (!available)
          {
            removeTag(JPEG_PROC);
          }
      }

    public Integer getJPEGProc()
      {
        return (Integer)getObject(JPEG_PROC);
      }

    public void setJPEGProc (final Integer jPEGProc)
      {
        setObject(JPEG_PROC, jPEGProc);
      }

    public boolean isJPEGInterchangeFormatAvailable()
      {
        return containsTag(JPEG_INTERCHANGE_FORMAT);
      }

    public void setJPEGInterchangeFormatAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_INTERCHANGE_FORMAT))
          {
            setJPEGInterchangeFormat(null);
          }
        else if (!available)
          {
            removeTag(JPEG_INTERCHANGE_FORMAT);
          }
      }

    public Integer getJPEGInterchangeFormat()
      {
        return (Integer)getObject(JPEG_INTERCHANGE_FORMAT);
      }

    public void setJPEGInterchangeFormat (final Integer jPEGInterchangeFormat)
      {
        setObject(JPEG_INTERCHANGE_FORMAT, jPEGInterchangeFormat);
      }

    public boolean isJPEGInterchangeFormatLengthAvailable()
      {
        return containsTag(JPEG_INTERCHANGE_FORMAT_LENGTH);
      }

    public void setJPEGInterchangeFormatLengthAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_INTERCHANGE_FORMAT_LENGTH))
          {
            setJPEGInterchangeFormatLength(null);
          }
        else if (!available)
          {
            removeTag(JPEG_INTERCHANGE_FORMAT_LENGTH);
          }
      }

    public Integer getJPEGInterchangeFormatLength()
      {
        return (Integer)getObject(JPEG_INTERCHANGE_FORMAT_LENGTH);
      }

    public void setJPEGInterchangeFormatLength (final Integer jPEGInterchangeFormatLength)
      {
        setObject(JPEG_INTERCHANGE_FORMAT_LENGTH, jPEGInterchangeFormatLength);
      }

    public boolean isJPEGRestartIntervalAvailable()
      {
        return containsTag(JPEG_RESTART_INTERVAL);
      }

    public void setJPEGRestartIntervalAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_RESTART_INTERVAL))
          {
            setJPEGRestartInterval(null);
          }
        else if (!available)
          {
            removeTag(JPEG_RESTART_INTERVAL);
          }
      }

    public Integer getJPEGRestartInterval()
      {
        return (Integer)getObject(JPEG_RESTART_INTERVAL);
      }

    public void setJPEGRestartInterval (final Integer jPEGRestartInterval)
      {
        setObject(JPEG_RESTART_INTERVAL, jPEGRestartInterval);
      }

    public boolean isJPEGLosslessPredictorsAvailable()
      {
        return containsTag(JPEG_LOSSLESS_PREDICTORS);
      }

    public void setJPEGLosslessPredictorsAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_LOSSLESS_PREDICTORS))
          {
            setJPEGLosslessPredictors(null);
          }
        else if (!available)
          {
            removeTag(JPEG_LOSSLESS_PREDICTORS);
          }
      }

    public int[] getJPEGLosslessPredictors()
      {
        return (int[])getObject(JPEG_LOSSLESS_PREDICTORS);
      }

    public void setJPEGLosslessPredictors (final int[] jPEGLosslessPredictors)
      {
        setObject(JPEG_LOSSLESS_PREDICTORS, jPEGLosslessPredictors);
      }

    public boolean isJPEGPointTransformsAvailable()
      {
        return containsTag(JPEG_POINT_TRANSFORMS);
      }

    public void setJPEGPointTransformsAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_POINT_TRANSFORMS))
          {
            setJPEGPointTransforms(null);
          }
        else if (!available)
          {
            removeTag(JPEG_POINT_TRANSFORMS);
          }
      }

    public int[] getJPEGPointTransforms()
      {
        return (int[])getObject(JPEG_POINT_TRANSFORMS);
      }

    public void setJPEGPointTransforms (final int[] jPEGPointTransforms)
      {
        setObject(JPEG_POINT_TRANSFORMS, jPEGPointTransforms);
      }

    public boolean isJPEGQTablesAvailable()
      {
        return containsTag(JPEG_Q_TABLES);
      }

    public void setJPEGQTablesAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_Q_TABLES))
          {
            setJPEGQTables(null);
          }
        else if (!available)
          {
            removeTag(JPEG_Q_TABLES);
          }
      }

    public int[] getJPEGQTables()
      {
        return (int[])getObject(JPEG_Q_TABLES);
      }

    public void setJPEGQTables (final int[] jPEGQTables)
      {
        setObject(JPEG_Q_TABLES, jPEGQTables);
      }

    public boolean isJPEGDCTablesAvailable()
      {
        return containsTag(JPEG_DC_TABLES);
      }

    public void setJPEGDCTablesAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_DC_TABLES))
          {
            setJPEGDCTables(null);
          }
        else if (!available)
          {
            removeTag(JPEG_DC_TABLES);
          }
      }

    public int[] getJPEGDCTables()
      {
        return (int[])getObject(JPEG_DC_TABLES);
      }

    public void setJPEGDCTables (final int[] jPEGDCTables)
      {
        setObject(JPEG_DC_TABLES, jPEGDCTables);
      }

    public boolean isJPEGACTablesAvailable()
      {
        return containsTag(JPEG_AC_TABLES);
      }

    public void setJPEGACTablesAvailable (final boolean available)
      {
        if (available && !containsTag(JPEG_AC_TABLES))
          {
            setJPEGACTables(null);
          }
        else if (!available)
          {
            removeTag(JPEG_AC_TABLES);
          }
      }

    public int[] getJPEGACTables()
      {
        return (int[])getObject(JPEG_AC_TABLES);
      }

    public void setJPEGACTables (final int[] jPEGACTables)
      {
        setObject(JPEG_AC_TABLES, jPEGACTables);
      }

    public boolean isYCbCrCoefficientsAvailable()
      {
        return containsTag(YCBCR_COEFFICIENTS);
      }

    public void setYCbCrCoefficientsAvailable (final boolean available)
      {
        if (available && !containsTag(YCBCR_COEFFICIENTS))
          {
            setYCbCrCoefficients(null);
          }
        else if (!available)
          {
            removeTag(YCBCR_COEFFICIENTS);
          }
      }

    public Rational[] getYCbCrCoefficients()
      {
        return (Rational[])getObject(YCBCR_COEFFICIENTS);
      }

    public void setYCbCrCoefficients (final Rational[] yCbCrCoefficients)
      {
        setObject(YCBCR_COEFFICIENTS, yCbCrCoefficients);
      }

    public boolean isYCbCrSubsamplingAvailable()
      {
        return containsTag(YCBCR_SUBSAMPLING);
      }

    public void setYCbCrSubsamplingAvailable (final boolean available)
      {
        if (available && !containsTag(YCBCR_SUBSAMPLING))
          {
            setYCbCrSubsampling(null);
          }
        else if (!available)
          {
            removeTag(YCBCR_SUBSAMPLING);
          }
      }

    public int[] getYCbCrSubsampling()
      {
        return (int[])getObject(YCBCR_SUBSAMPLING);
      }

    public void setYCbCrSubsampling (final int[] yCbCrSubsampling)
      {
        setObject(YCBCR_SUBSAMPLING, yCbCrSubsampling);
      }

    public boolean isYCbCrPositioningAvailable()
      {
        return containsTag(YCBCR_POSITIONING);
      }

    public void setYCbCrPositioningAvailable (final boolean available)
      {
        if (available && !containsTag(YCBCR_POSITIONING))
          {
            setYCbCrPositioning(null);
          }
        else if (!available)
          {
            removeTag(YCBCR_POSITIONING);
          }
      }

    public Integer getYCbCrPositioning()
      {
        return (Integer)getObject(YCBCR_POSITIONING);
      }

    public void setYCbCrPositioning (final Integer yCbCrPositioning)
      {
        setObject(YCBCR_POSITIONING, yCbCrPositioning);
      }

    public boolean isReferenceBlackWhiteAvailable()
      {
        return containsTag(REFERENCE_BLACK_WHITE);
      }

    public void setReferenceBlackWhiteAvailable (final boolean available)
      {
        if (available && !containsTag(REFERENCE_BLACK_WHITE))
          {
            setReferenceBlackWhite(null);
          }
        else if (!available)
          {
            removeTag(REFERENCE_BLACK_WHITE);
          }
      }

    public Rational[] getReferenceBlackWhite()
      {
        return (Rational[])getObject(REFERENCE_BLACK_WHITE);
      }

    public void setReferenceBlackWhite (final Rational[] referenceBlackWhite)
      {
        setObject(REFERENCE_BLACK_WHITE, referenceBlackWhite);
      }

    public boolean isXMPAvailable()
      {
        return containsTag(XMP);
      }

    public void setXMPAvailable (final boolean available)
      {
        if (available && !containsTag(XMP))
          {
            setXMP(null);
          }
        else if (!available)
          {
            removeTag(XMP);
          }
      }

    public byte[] getXMP()
      {
        return (byte[])getObject(XMP);
      }

    public void setXMP (final byte[] xMP)
      {
        setObject(XMP, xMP);
      }

    public boolean isImageIDAvailable()
      {
        return containsTag(IMAGE_ID);
      }

    public void setImageIDAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_ID))
          {
            setImageID(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_ID);
          }
      }

    public String getImageID()
      {
        return (String)getObject(IMAGE_ID);
      }

    public void setImageID (final String imageID)
      {
        setObject(IMAGE_ID, imageID);
      }

    public boolean isCFARepeatPatternDimAvailable()
      {
        return containsTag(CFA_REPEAT_PATTERN_DIM);
      }

    public void setCFARepeatPatternDimAvailable (final boolean available)
      {
        if (available && !containsTag(CFA_REPEAT_PATTERN_DIM))
          {
            setCFARepeatPatternDim(null);
          }
        else if (!available)
          {
            removeTag(CFA_REPEAT_PATTERN_DIM);
          }
      }

    public int[] getCFARepeatPatternDim()
      {
        return (int[])getObject(CFA_REPEAT_PATTERN_DIM);
      }

    public void setCFARepeatPatternDim (final int[] cFARepeatPatternDim)
      {
        setObject(CFA_REPEAT_PATTERN_DIM, cFARepeatPatternDim);
      }

    public boolean isCFAPatternAvailable()
      {
        return containsTag(CFA_PATTERN);
      }

    public void setCFAPatternAvailable (final boolean available)
      {
        if (available && !containsTag(CFA_PATTERN))
          {
            setCFAPattern(null);
          }
        else if (!available)
          {
            removeTag(CFA_PATTERN);
          }
      }

    public byte[] getCFAPattern()
      {
        return (byte[])getObject(CFA_PATTERN);
      }

    public void setCFAPattern (final byte[] cFAPattern)
      {
        setObject(CFA_PATTERN, cFAPattern);
      }

    public boolean isBatteryLevelAvailable()
      {
        return containsTag(BATTERY_LEVEL);
      }

    public void setBatteryLevelAvailable (final boolean available)
      {
        if (available && !containsTag(BATTERY_LEVEL))
          {
            setBatteryLevel(null);
          }
        else if (!available)
          {
            removeTag(BATTERY_LEVEL);
          }
      }

    public String getBatteryLevel()
      {
        return (String)getObject(BATTERY_LEVEL);
      }

    public void setBatteryLevel (final String batteryLevel)
      {
        setObject(BATTERY_LEVEL, batteryLevel);
      }

    public boolean isCopyrightAvailable()
      {
        return containsTag(COPYRIGHT);
      }

    public void setCopyrightAvailable (final boolean available)
      {
        if (available && !containsTag(COPYRIGHT))
          {
            setCopyright(null);
          }
        else if (!available)
          {
            removeTag(COPYRIGHT);
          }
      }

    public String getCopyright()
      {
        return (String)getObject(COPYRIGHT);
      }

    public void setCopyright (final String copyright)
      {
        setObject(COPYRIGHT, copyright);
      }

    public boolean isExposureTimeAvailable()
      {
        return containsTag(EXPOSURE_TIME);
      }

    public void setExposureTimeAvailable (final boolean available)
      {
        if (available && !containsTag(EXPOSURE_TIME))
          {
            setExposureTime(null);
          }
        else if (!available)
          {
            removeTag(EXPOSURE_TIME);
          }
      }

    public Rational getExposureTime()
      {
        return (Rational)getObject(EXPOSURE_TIME);
      }

    public void setExposureTime (final Rational exposureTime)
      {
        setObject(EXPOSURE_TIME, exposureTime);
      }

    public boolean isFNumberAvailable()
      {
        return containsTag(F_NUMBER);
      }

    public void setFNumberAvailable (final boolean available)
      {
        if (available && !containsTag(F_NUMBER))
          {
            setFNumber(null);
          }
        else if (!available)
          {
            removeTag(F_NUMBER);
          }
      }

    public Rational getFNumber()
      {
        return (Rational)getObject(F_NUMBER);
      }

    public void setFNumber (final Rational fNumber)
      {
        setObject(F_NUMBER, fNumber);
      }

    public boolean isIPTCNAAAvailable()
      {
        return containsTag(IPTC_NAA);
      }

    public void setIPTCNAAAvailable (final boolean available)
      {
        if (available && !containsTag(IPTC_NAA))
          {
            setIPTCNAA(null);
          }
        else if (!available)
          {
            removeTag(IPTC_NAA);
          }
      }

    public String getIPTCNAA()
      {
        return (String)getObject(IPTC_NAA);
      }

    public void setIPTCNAA (final String iPTCNAA)
      {
        setObject(IPTC_NAA, iPTCNAA);
      }

    public boolean isModelPixelScaleTagAvailable()
      {
        return containsTag(MODEL_PIXEL_SCALE_TAG);
      }

    public void setModelPixelScaleTagAvailable (final boolean available)
      {
        if (available && !containsTag(MODEL_PIXEL_SCALE_TAG))
          {
            setModelPixelScaleTag(null);
          }
        else if (!available)
          {
            removeTag(MODEL_PIXEL_SCALE_TAG);
          }
      }

    public double[] getModelPixelScaleTag()
      {
        return (double[])getObject(MODEL_PIXEL_SCALE_TAG);
      }

    public void setModelPixelScaleTag (final double[] modelPixelScaleTag)
      {
        setObject(MODEL_PIXEL_SCALE_TAG, modelPixelScaleTag);
      }

    public boolean isIntergraphMatrixTagAvailable()
      {
        return containsTag(INTERGRAPH_MATRIX_TAG);
      }

    public void setIntergraphMatrixTagAvailable (final boolean available)
      {
        if (available && !containsTag(INTERGRAPH_MATRIX_TAG))
          {
            setIntergraphMatrixTag(null);
          }
        else if (!available)
          {
            removeTag(INTERGRAPH_MATRIX_TAG);
          }
      }

    public double[] getIntergraphMatrixTag()
      {
        return (double[])getObject(INTERGRAPH_MATRIX_TAG);
      }

    public void setIntergraphMatrixTag (final double[] intergraphMatrixTag)
      {
        setObject(INTERGRAPH_MATRIX_TAG, intergraphMatrixTag);
      }

    public boolean isModelTiepointTagAvailable()
      {
        return containsTag(MODEL_TIEPOINT_TAG);
      }

    public void setModelTiepointTagAvailable (final boolean available)
      {
        if (available && !containsTag(MODEL_TIEPOINT_TAG))
          {
            setModelTiepointTag(null);
          }
        else if (!available)
          {
            removeTag(MODEL_TIEPOINT_TAG);
          }
      }

    public double[] getModelTiepointTag()
      {
        return (double[])getObject(MODEL_TIEPOINT_TAG);
      }

    public void setModelTiepointTag (final double[] modelTiepointTag)
      {
        setObject(MODEL_TIEPOINT_TAG, modelTiepointTag);
      }

    public boolean isSiteAvailable()
      {
        return containsTag(SITE);
      }

    public void setSiteAvailable (final boolean available)
      {
        if (available && !containsTag(SITE))
          {
            setSite(null);
          }
        else if (!available)
          {
            removeTag(SITE);
          }
      }

    public String getSite()
      {
        return (String)getObject(SITE);
      }

    public void setSite (final String site)
      {
        setObject(SITE, site);
      }

    public boolean isColorSequenceAvailable()
      {
        return containsTag(COLOR_SEQUENCE);
      }

    public void setColorSequenceAvailable (final boolean available)
      {
        if (available && !containsTag(COLOR_SEQUENCE))
          {
            setColorSequence(null);
          }
        else if (!available)
          {
            removeTag(COLOR_SEQUENCE);
          }
      }

    public String getColorSequence()
      {
        return (String)getObject(COLOR_SEQUENCE);
      }

    public void setColorSequence (final String colorSequence)
      {
        setObject(COLOR_SEQUENCE, colorSequence);
      }

    public boolean isIT8HeaderAvailable()
      {
        return containsTag(IT8_HEADER);
      }

    public void setIT8HeaderAvailable (final boolean available)
      {
        if (available && !containsTag(IT8_HEADER))
          {
            setIT8Header(null);
          }
        else if (!available)
          {
            removeTag(IT8_HEADER);
          }
      }

    public String getIT8Header()
      {
        return (String)getObject(IT8_HEADER);
      }

    public void setIT8Header (final String iT8Header)
      {
        setObject(IT8_HEADER, iT8Header);
      }

    public boolean isRasterPaddingAvailable()
      {
        return containsTag(RASTER_PADDING);
      }

    public void setRasterPaddingAvailable (final boolean available)
      {
        if (available && !containsTag(RASTER_PADDING))
          {
            setRasterPadding(null);
          }
        else if (!available)
          {
            removeTag(RASTER_PADDING);
          }
      }

    public Integer getRasterPadding()
      {
        return (Integer)getObject(RASTER_PADDING);
      }

    public void setRasterPadding (final Integer rasterPadding)
      {
        setObject(RASTER_PADDING, rasterPadding);
      }

    public boolean isBitsPerRunLengthAvailable()
      {
        return containsTag(BITS_PER_RUN_LENGTH);
      }

    public void setBitsPerRunLengthAvailable (final boolean available)
      {
        if (available && !containsTag(BITS_PER_RUN_LENGTH))
          {
            setBitsPerRunLength(null);
          }
        else if (!available)
          {
            removeTag(BITS_PER_RUN_LENGTH);
          }
      }

    public Integer getBitsPerRunLength()
      {
        return (Integer)getObject(BITS_PER_RUN_LENGTH);
      }

    public void setBitsPerRunLength (final Integer bitsPerRunLength)
      {
        setObject(BITS_PER_RUN_LENGTH, bitsPerRunLength);
      }

    public boolean isBitsPerExtendedRunLengthAvailable()
      {
        return containsTag(BITS_PER_EXTENDED_RUN_LENGTH);
      }

    public void setBitsPerExtendedRunLengthAvailable (final boolean available)
      {
        if (available && !containsTag(BITS_PER_EXTENDED_RUN_LENGTH))
          {
            setBitsPerExtendedRunLength(null);
          }
        else if (!available)
          {
            removeTag(BITS_PER_EXTENDED_RUN_LENGTH);
          }
      }

    public Integer getBitsPerExtendedRunLength()
      {
        return (Integer)getObject(BITS_PER_EXTENDED_RUN_LENGTH);
      }

    public void setBitsPerExtendedRunLength (final Integer bitsPerExtendedRunLength)
      {
        setObject(BITS_PER_EXTENDED_RUN_LENGTH, bitsPerExtendedRunLength);
      }

    public boolean isColorTableAvailable()
      {
        return containsTag(COLOR_TABLE);
      }

    public void setColorTableAvailable (final boolean available)
      {
        if (available && !containsTag(COLOR_TABLE))
          {
            setColorTable(null);
          }
        else if (!available)
          {
            removeTag(COLOR_TABLE);
          }
      }

    public byte[] getColorTable()
      {
        return (byte[])getObject(COLOR_TABLE);
      }

    public void setColorTable (final byte[] colorTable)
      {
        setObject(COLOR_TABLE, colorTable);
      }

    public boolean isImageColorIndicatorAvailable()
      {
        return containsTag(IMAGE_COLOR_INDICATOR);
      }

    public void setImageColorIndicatorAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_COLOR_INDICATOR))
          {
            setImageColorIndicator(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_COLOR_INDICATOR);
          }
      }

    public Integer getImageColorIndicator()
      {
        return (Integer)getObject(IMAGE_COLOR_INDICATOR);
      }

    public void setImageColorIndicator (final Integer imageColorIndicator)
      {
        setObject(IMAGE_COLOR_INDICATOR, imageColorIndicator);
      }

    public boolean isBackgroundColorIndicatorAvailable()
      {
        return containsTag(BACKGROUND_COLOR_INDICATOR);
      }

    public void setBackgroundColorIndicatorAvailable (final boolean available)
      {
        if (available && !containsTag(BACKGROUND_COLOR_INDICATOR))
          {
            setBackgroundColorIndicator(null);
          }
        else if (!available)
          {
            removeTag(BACKGROUND_COLOR_INDICATOR);
          }
      }

    public Integer getBackgroundColorIndicator()
      {
        return (Integer)getObject(BACKGROUND_COLOR_INDICATOR);
      }

    public void setBackgroundColorIndicator (final Integer backgroundColorIndicator)
      {
        setObject(BACKGROUND_COLOR_INDICATOR, backgroundColorIndicator);
      }

    public boolean isImageColorValueAvailable()
      {
        return containsTag(IMAGE_COLOR_VALUE);
      }

    public void setImageColorValueAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_COLOR_VALUE))
          {
            setImageColorValue(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_COLOR_VALUE);
          }
      }

    public Integer getImageColorValue()
      {
        return (Integer)getObject(IMAGE_COLOR_VALUE);
      }

    public void setImageColorValue (final Integer imageColorValue)
      {
        setObject(IMAGE_COLOR_VALUE, imageColorValue);
      }

    public boolean isBackgroundColorValueAvailable()
      {
        return containsTag(BACKGROUND_COLOR_VALUE);
      }

    public void setBackgroundColorValueAvailable (final boolean available)
      {
        if (available && !containsTag(BACKGROUND_COLOR_VALUE))
          {
            setBackgroundColorValue(null);
          }
        else if (!available)
          {
            removeTag(BACKGROUND_COLOR_VALUE);
          }
      }

    public Integer getBackgroundColorValue()
      {
        return (Integer)getObject(BACKGROUND_COLOR_VALUE);
      }

    public void setBackgroundColorValue (final Integer backgroundColorValue)
      {
        setObject(BACKGROUND_COLOR_VALUE, backgroundColorValue);
      }

    public boolean isPixelIntensityRangeAvailable()
      {
        return containsTag(PIXEL_INTENSITY_RANGE);
      }

    public void setPixelIntensityRangeAvailable (final boolean available)
      {
        if (available && !containsTag(PIXEL_INTENSITY_RANGE))
          {
            setPixelIntensityRange(null);
          }
        else if (!available)
          {
            removeTag(PIXEL_INTENSITY_RANGE);
          }
      }

    public byte[] getPixelIntensityRange()
      {
        return (byte[])getObject(PIXEL_INTENSITY_RANGE);
      }

    public void setPixelIntensityRange (final byte[] pixelIntensityRange)
      {
        setObject(PIXEL_INTENSITY_RANGE, pixelIntensityRange);
      }

    public boolean isTransparencyIndicatorAvailable()
      {
        return containsTag(TRANSPARENCY_INDICATOR);
      }

    public void setTransparencyIndicatorAvailable (final boolean available)
      {
        if (available && !containsTag(TRANSPARENCY_INDICATOR))
          {
            setTransparencyIndicator(null);
          }
        else if (!available)
          {
            removeTag(TRANSPARENCY_INDICATOR);
          }
      }

    public Integer getTransparencyIndicator()
      {
        return (Integer)getObject(TRANSPARENCY_INDICATOR);
      }

    public void setTransparencyIndicator (final Integer transparencyIndicator)
      {
        setObject(TRANSPARENCY_INDICATOR, transparencyIndicator);
      }

    public boolean isColorCharacterizationAvailable()
      {
        return containsTag(COLOR_CHARACTERIZATION);
      }

    public void setColorCharacterizationAvailable (final boolean available)
      {
        if (available && !containsTag(COLOR_CHARACTERIZATION))
          {
            setColorCharacterization(null);
          }
        else if (!available)
          {
            removeTag(COLOR_CHARACTERIZATION);
          }
      }

    public String getColorCharacterization()
      {
        return (String)getObject(COLOR_CHARACTERIZATION);
      }

    public void setColorCharacterization (final String colorCharacterization)
      {
        setObject(COLOR_CHARACTERIZATION, colorCharacterization);
      }

    public boolean isHCUsageAvailable()
      {
        return containsTag(HC_USAGE);
      }

    public void setHCUsageAvailable (final boolean available)
      {
        if (available && !containsTag(HC_USAGE))
          {
            setHCUsage(null);
          }
        else if (!available)
          {
            removeTag(HC_USAGE);
          }
      }

    public Long getHCUsage()
      {
        return (Long)getObject(HC_USAGE);
      }

    public void setHCUsage (final Long hCUsage)
      {
        setObject(HC_USAGE, hCUsage);
      }

    public boolean isModelTransformationTagAvailable()
      {
        return containsTag(MODEL_TRANSFORMATION_TAG);
      }

    public void setModelTransformationTagAvailable (final boolean available)
      {
        if (available && !containsTag(MODEL_TRANSFORMATION_TAG))
          {
            setModelTransformationTag(null);
          }
        else if (!available)
          {
            removeTag(MODEL_TRANSFORMATION_TAG);
          }
      }

    public double[] getModelTransformationTag()
      {
        return (double[])getObject(MODEL_TRANSFORMATION_TAG);
      }

    public void setModelTransformationTag (final double[] modelTransformationTag)
      {
        setObject(MODEL_TRANSFORMATION_TAG, modelTransformationTag);
      }

    public boolean isPhotoshopImageResourcesAvailable()
      {
        return containsTag(PHOTOSHOP_IMAGE_RESOURCES);
      }

    public void setPhotoshopImageResourcesAvailable (final boolean available)
      {
        if (available && !containsTag(PHOTOSHOP_IMAGE_RESOURCES))
          {
            setPhotoshopImageResources(null);
          }
        else if (!available)
          {
            removeTag(PHOTOSHOP_IMAGE_RESOURCES);
          }
      }

    public Integer getPhotoshopImageResources()
      {
        return (Integer)getObject(PHOTOSHOP_IMAGE_RESOURCES);
      }

    public void setPhotoshopImageResources (final Integer photoshopImageResources)
      {
        setObject(PHOTOSHOP_IMAGE_RESOURCES, photoshopImageResources);
      }

    public boolean isExifIFDPointerAvailable()
      {
        return containsTag(EXIF_IFD_POINTER);
      }

    public void setExifIFDPointerAvailable (final boolean available)
      {
        if (available && !containsTag(EXIF_IFD_POINTER))
          {
            setExifIFDPointer(null);
          }
        else if (!available)
          {
            removeTag(EXIF_IFD_POINTER);
          }
      }

    public Long getExifIFDPointer()
      {
        return (Long)getObject(EXIF_IFD_POINTER);
      }

    public void setExifIFDPointer (final Long exifIFDPointer)
      {
        setObject(EXIF_IFD_POINTER, exifIFDPointer);
      }

    public boolean isInterColourProfileAvailable()
      {
        return containsTag(INTER_COLOUR_PROFILE);
      }

    public void setInterColourProfileAvailable (final boolean available)
      {
        if (available && !containsTag(INTER_COLOUR_PROFILE))
          {
            setInterColourProfile(null);
          }
        else if (!available)
          {
            removeTag(INTER_COLOUR_PROFILE);
          }
      }

    public byte[] getInterColourProfile()
      {
        return (byte[])getObject(INTER_COLOUR_PROFILE);
      }

    public void setInterColourProfile (final byte[] interColourProfile)
      {
        setObject(INTER_COLOUR_PROFILE, interColourProfile);
      }

    public boolean isGeoKeyDirectoryTagAvailable()
      {
        return containsTag(GEO_KEY_DIRECTORYTAG);
      }

    public void setGeoKeyDirectoryTagAvailable (final boolean available)
      {
        if (available && !containsTag(GEO_KEY_DIRECTORYTAG))
          {
            setGeoKeyDirectoryTag(null);
          }
        else if (!available)
          {
            removeTag(GEO_KEY_DIRECTORYTAG);
          }
      }

    public int[] getGeoKeyDirectoryTag()
      {
        return (int[])getObject(GEO_KEY_DIRECTORYTAG);
      }

    public void setGeoKeyDirectoryTag (final int[] geoKeyDirectoryTag)
      {
        setObject(GEO_KEY_DIRECTORYTAG, geoKeyDirectoryTag);
      }

    public boolean isGeoDoubleParamsTagAvailable()
      {
        return containsTag(GEO_DOUBLE_PARAMS_TAG);
      }

    public void setGeoDoubleParamsTagAvailable (final boolean available)
      {
        if (available && !containsTag(GEO_DOUBLE_PARAMS_TAG))
          {
            setGeoDoubleParamsTag(null);
          }
        else if (!available)
          {
            removeTag(GEO_DOUBLE_PARAMS_TAG);
          }
      }

    public double[] getGeoDoubleParamsTag()
      {
        return (double[])getObject(GEO_DOUBLE_PARAMS_TAG);
      }

    public void setGeoDoubleParamsTag (final double[] geoDoubleParamsTag)
      {
        setObject(GEO_DOUBLE_PARAMS_TAG, geoDoubleParamsTag);
      }

    public boolean isGeoAsciiParamsTagAvailable()
      {
        return containsTag(GEO_ASCII_PARAMS_TAG);
      }

    public void setGeoAsciiParamsTagAvailable (final boolean available)
      {
        if (available && !containsTag(GEO_ASCII_PARAMS_TAG))
          {
            setGeoAsciiParamsTag(null);
          }
        else if (!available)
          {
            removeTag(GEO_ASCII_PARAMS_TAG);
          }
      }

    public String getGeoAsciiParamsTag()
      {
        return (String)getObject(GEO_ASCII_PARAMS_TAG);
      }

    public void setGeoAsciiParamsTag (final String geoAsciiParamsTag)
      {
        setObject(GEO_ASCII_PARAMS_TAG, geoAsciiParamsTag);
      }

    public static enum ExposureProgram
       {
         NOT_DEFINED(0, "not defined"),
         MANUAL(1, "manual"),
         NORMAL_PROGRAM(2, "normal program"),
         APERTURE_PRIORITY(3, "aperture priority"),
         SHUTTER_PRIORITY(4, "shutter priority"),
         CREATIVE_PROGRAM(5, "creative program"),
         ACTION_PROGRAM(6, "action program"),
         PORTRAIT_MODE(7, "portrait mode"),
         LANDSCAPE_MODE(8, "landscape mode"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private ExposureProgram (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static ExposureProgram fromInteger(int value)
           {
             if (value == (short)0) return NOT_DEFINED;
             if (value == (short)1) return MANUAL;
             if (value == (short)2) return NORMAL_PROGRAM;
             if (value == (short)3) return APERTURE_PRIORITY;
             if (value == (short)4) return SHUTTER_PRIORITY;
             if (value == (short)5) return CREATIVE_PROGRAM;
             if (value == (short)6) return ACTION_PROGRAM;
             if (value == (short)7) return PORTRAIT_MODE;
             if (value == (short)8) return LANDSCAPE_MODE;

             return _UNKNOWN;
           }
       }
    public boolean isExposureProgramAvailable()
      {
        return containsTag(EXPOSURE_PROGRAM);
      }

    public void setExposureProgramAvailable (final boolean available)
      {
        if (available && !containsTag(EXPOSURE_PROGRAM))
          {
            setExposureProgram(null);
          }
        else if (!available)
          {
            removeTag(EXPOSURE_PROGRAM);
          }
      }

    public ExposureProgram getExposureProgram()
      {
        return (ExposureProgram)getObject(EXPOSURE_PROGRAM);
      }

    public void setExposureProgram (final ExposureProgram exposureProgram)
      {
        setObject(EXPOSURE_PROGRAM, exposureProgram);
      }

    public boolean isSpectralSensitivityAvailable()
      {
        return containsTag(SPECTRAL_SENSITIVITY);
      }

    public void setSpectralSensitivityAvailable (final boolean available)
      {
        if (available && !containsTag(SPECTRAL_SENSITIVITY))
          {
            setSpectralSensitivity(null);
          }
        else if (!available)
          {
            removeTag(SPECTRAL_SENSITIVITY);
          }
      }

    public String getSpectralSensitivity()
      {
        return (String)getObject(SPECTRAL_SENSITIVITY);
      }

    public void setSpectralSensitivity (final String spectralSensitivity)
      {
        setObject(SPECTRAL_SENSITIVITY, spectralSensitivity);
      }

    public boolean isGPSInfoIFDPointerAvailable()
      {
        return containsTag(GPS_INFO_IFD_POINTER);
      }

    public void setGPSInfoIFDPointerAvailable (final boolean available)
      {
        if (available && !containsTag(GPS_INFO_IFD_POINTER))
          {
            setGPSInfoIFDPointer(null);
          }
        else if (!available)
          {
            removeTag(GPS_INFO_IFD_POINTER);
          }
      }

    public Long getGPSInfoIFDPointer()
      {
        return (Long)getObject(GPS_INFO_IFD_POINTER);
      }

    public void setGPSInfoIFDPointer (final Long gPSInfoIFDPointer)
      {
        setObject(GPS_INFO_IFD_POINTER, gPSInfoIFDPointer);
      }

    public boolean isISOSpeedRatingsAvailable()
      {
        return containsTag(ISO_SPEED_RATINGS);
      }

    public void setISOSpeedRatingsAvailable (final boolean available)
      {
        if (available && !containsTag(ISO_SPEED_RATINGS))
          {
            setISOSpeedRatings(null);
          }
        else if (!available)
          {
            removeTag(ISO_SPEED_RATINGS);
          }
      }

    public Integer getISOSpeedRatings()
      {
        return (Integer)getObject(ISO_SPEED_RATINGS);
      }

    public void setISOSpeedRatings (final Integer iSOSpeedRatings)
      {
        setObject(ISO_SPEED_RATINGS, iSOSpeedRatings);
      }

    public boolean isOECFAvailable()
      {
        return containsTag(OECF);
      }

    public void setOECFAvailable (final boolean available)
      {
        if (available && !containsTag(OECF))
          {
            setOECF(null);
          }
        else if (!available)
          {
            removeTag(OECF);
          }
      }

    public byte[] getOECF()
      {
        return (byte[])getObject(OECF);
      }

    public void setOECF (final byte[] oECF)
      {
        setObject(OECF, oECF);
      }

    public boolean isInterlaceAvailable()
      {
        return containsTag(INTERLACE);
      }

    public void setInterlaceAvailable (final boolean available)
      {
        if (available && !containsTag(INTERLACE))
          {
            setInterlace(null);
          }
        else if (!available)
          {
            removeTag(INTERLACE);
          }
      }

    public Integer getInterlace()
      {
        return (Integer)getObject(INTERLACE);
      }

    public void setInterlace (final Integer interlace)
      {
        setObject(INTERLACE, interlace);
      }

    public boolean isTimeZoneOffsetAvailable()
      {
        return containsTag(TIME_ZONE_OFFSET);
      }

    public void setTimeZoneOffsetAvailable (final boolean available)
      {
        if (available && !containsTag(TIME_ZONE_OFFSET))
          {
            setTimeZoneOffset(null);
          }
        else if (!available)
          {
            removeTag(TIME_ZONE_OFFSET);
          }
      }

    public int[] getTimeZoneOffset()
      {
        return (int[])getObject(TIME_ZONE_OFFSET);
      }

    public void setTimeZoneOffset (final int[] timeZoneOffset)
      {
        setObject(TIME_ZONE_OFFSET, timeZoneOffset);
      }

    public boolean isSelfTimerModeAvailable()
      {
        return containsTag(SELF_TIMER_MODE);
      }

    public void setSelfTimerModeAvailable (final boolean available)
      {
        if (available && !containsTag(SELF_TIMER_MODE))
          {
            setSelfTimerMode(null);
          }
        else if (!available)
          {
            removeTag(SELF_TIMER_MODE);
          }
      }

    public Integer getSelfTimerMode()
      {
        return (Integer)getObject(SELF_TIMER_MODE);
      }

    public void setSelfTimerMode (final Integer selfTimerMode)
      {
        setObject(SELF_TIMER_MODE, selfTimerMode);
      }

    public boolean isEXIFVersionAvailable()
      {
        return containsTag(EXIF_VERSION);
      }

    public void setEXIFVersionAvailable (final boolean available)
      {
        if (available && !containsTag(EXIF_VERSION))
          {
            setEXIFVersion(null);
          }
        else if (!available)
          {
            removeTag(EXIF_VERSION);
          }
      }

    public byte[] getEXIFVersion()
      {
        return (byte[])getObject(EXIF_VERSION);
      }

    public void setEXIFVersion (final byte[] eXIFVersion)
      {
        setObject(EXIF_VERSION, eXIFVersion);
      }

    public boolean isDateTimeOriginalAvailable()
      {
        return containsTag(DATETIME_ORIGINAL);
      }

    public void setDateTimeOriginalAvailable (final boolean available)
      {
        if (available && !containsTag(DATETIME_ORIGINAL))
          {
            setDateTimeOriginal(null);
          }
        else if (!available)
          {
            removeTag(DATETIME_ORIGINAL);
          }
      }

    public String getDateTimeOriginal()
      {
        return (String)getObject(DATETIME_ORIGINAL);
      }

    public void setDateTimeOriginal (final String dateTimeOriginal)
      {
        setObject(DATETIME_ORIGINAL, dateTimeOriginal);
      }

    public boolean isDateTimeDigitizedAvailable()
      {
        return containsTag(DATETIME_DIGITIZED);
      }

    public void setDateTimeDigitizedAvailable (final boolean available)
      {
        if (available && !containsTag(DATETIME_DIGITIZED))
          {
            setDateTimeDigitized(null);
          }
        else if (!available)
          {
            removeTag(DATETIME_DIGITIZED);
          }
      }

    public String getDateTimeDigitized()
      {
        return (String)getObject(DATETIME_DIGITIZED);
      }

    public void setDateTimeDigitized (final String dateTimeDigitized)
      {
        setObject(DATETIME_DIGITIZED, dateTimeDigitized);
      }

    public boolean isComponentConfigurationAvailable()
      {
        return containsTag(COMPONENT_CONFIGURATION);
      }

    public void setComponentConfigurationAvailable (final boolean available)
      {
        if (available && !containsTag(COMPONENT_CONFIGURATION))
          {
            setComponentConfiguration(null);
          }
        else if (!available)
          {
            removeTag(COMPONENT_CONFIGURATION);
          }
      }

    public byte[] getComponentConfiguration()
      {
        return (byte[])getObject(COMPONENT_CONFIGURATION);
      }

    public void setComponentConfiguration (final byte[] componentConfiguration)
      {
        setObject(COMPONENT_CONFIGURATION, componentConfiguration);
      }

    public boolean isCompressedBitsPerPixelAvailable()
      {
        return containsTag(COMPRESSED_BITS_PER_PIXEL);
      }

    public void setCompressedBitsPerPixelAvailable (final boolean available)
      {
        if (available && !containsTag(COMPRESSED_BITS_PER_PIXEL))
          {
            setCompressedBitsPerPixel(null);
          }
        else if (!available)
          {
            removeTag(COMPRESSED_BITS_PER_PIXEL);
          }
      }

    public Rational getCompressedBitsPerPixel()
      {
        return (Rational)getObject(COMPRESSED_BITS_PER_PIXEL);
      }

    public void setCompressedBitsPerPixel (final Rational compressedBitsPerPixel)
      {
        setObject(COMPRESSED_BITS_PER_PIXEL, compressedBitsPerPixel);
      }

    public boolean isShutterSpeedValueAvailable()
      {
        return containsTag(SHUTTER_SPEEDVALUE);
      }

    public void setShutterSpeedValueAvailable (final boolean available)
      {
        if (available && !containsTag(SHUTTER_SPEEDVALUE))
          {
            setShutterSpeedValue(null);
          }
        else if (!available)
          {
            removeTag(SHUTTER_SPEEDVALUE);
          }
      }

    public Rational getShutterSpeedValue()
      {
        return (Rational)getObject(SHUTTER_SPEEDVALUE);
      }

    public void setShutterSpeedValue (final Rational shutterSpeedValue)
      {
        setObject(SHUTTER_SPEEDVALUE, shutterSpeedValue);
      }

    public boolean isApertureValueAvailable()
      {
        return containsTag(APERTURE_VALUE);
      }

    public void setApertureValueAvailable (final boolean available)
      {
        if (available && !containsTag(APERTURE_VALUE))
          {
            setApertureValue(null);
          }
        else if (!available)
          {
            removeTag(APERTURE_VALUE);
          }
      }

    public Rational getApertureValue()
      {
        return (Rational)getObject(APERTURE_VALUE);
      }

    public void setApertureValue (final Rational apertureValue)
      {
        setObject(APERTURE_VALUE, apertureValue);
      }

    public boolean isBrightnessValueAvailable()
      {
        return containsTag(BRIGHTNESS_VALUE);
      }

    public void setBrightnessValueAvailable (final boolean available)
      {
        if (available && !containsTag(BRIGHTNESS_VALUE))
          {
            setBrightnessValue(null);
          }
        else if (!available)
          {
            removeTag(BRIGHTNESS_VALUE);
          }
      }

    public Rational getBrightnessValue()
      {
        return (Rational)getObject(BRIGHTNESS_VALUE);
      }

    public void setBrightnessValue (final Rational brightnessValue)
      {
        setObject(BRIGHTNESS_VALUE, brightnessValue);
      }

    public boolean isExposureBiasValueAvailable()
      {
        return containsTag(EXPOSURE_BIAS_VALUE);
      }

    public void setExposureBiasValueAvailable (final boolean available)
      {
        if (available && !containsTag(EXPOSURE_BIAS_VALUE))
          {
            setExposureBiasValue(null);
          }
        else if (!available)
          {
            removeTag(EXPOSURE_BIAS_VALUE);
          }
      }

    public Rational getExposureBiasValue()
      {
        return (Rational)getObject(EXPOSURE_BIAS_VALUE);
      }

    public void setExposureBiasValue (final Rational exposureBiasValue)
      {
        setObject(EXPOSURE_BIAS_VALUE, exposureBiasValue);
      }

    public boolean isMaxApertureValueAvailable()
      {
        return containsTag(MAX_APERTURE_VALUE);
      }

    public void setMaxApertureValueAvailable (final boolean available)
      {
        if (available && !containsTag(MAX_APERTURE_VALUE))
          {
            setMaxApertureValue(null);
          }
        else if (!available)
          {
            removeTag(MAX_APERTURE_VALUE);
          }
      }

    public Rational getMaxApertureValue()
      {
        return (Rational)getObject(MAX_APERTURE_VALUE);
      }

    public void setMaxApertureValue (final Rational maxApertureValue)
      {
        setObject(MAX_APERTURE_VALUE, maxApertureValue);
      }

    public boolean isSubjectDistanceAvailable()
      {
        return containsTag(SUBJECT_DISTANCE);
      }

    public void setSubjectDistanceAvailable (final boolean available)
      {
        if (available && !containsTag(SUBJECT_DISTANCE))
          {
            setSubjectDistance(null);
          }
        else if (!available)
          {
            removeTag(SUBJECT_DISTANCE);
          }
      }

    public Rational getSubjectDistance()
      {
        return (Rational)getObject(SUBJECT_DISTANCE);
      }

    public void setSubjectDistance (final Rational subjectDistance)
      {
        setObject(SUBJECT_DISTANCE, subjectDistance);
      }

    public static enum MeteringMode
       {
         UNKNOWN(0, "unknown"),
         AVERAGE(1, "average"),
         CENTER_WEIGHTED_AVERAGE(2, "center weighted average"),
         SPOT(3, "spot"),
         MULTISPOT(4, "multispot"),
         PATTERN(5, "pattern"),
         PARTIAL(6, "partial"),
         OTHER(255, "other"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private MeteringMode (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static MeteringMode fromInteger(int value)
           {
             if (value == (short)0) return UNKNOWN;
             if (value == (short)1) return AVERAGE;
             if (value == (short)2) return CENTER_WEIGHTED_AVERAGE;
             if (value == (short)3) return SPOT;
             if (value == (short)4) return MULTISPOT;
             if (value == (short)5) return PATTERN;
             if (value == (short)6) return PARTIAL;
             if (value == (short)255) return OTHER;

             return _UNKNOWN;
           }
       }
    public boolean isMeteringModeAvailable()
      {
        return containsTag(METERING_MODE);
      }

    public void setMeteringModeAvailable (final boolean available)
      {
        if (available && !containsTag(METERING_MODE))
          {
            setMeteringMode(null);
          }
        else if (!available)
          {
            removeTag(METERING_MODE);
          }
      }

    public MeteringMode getMeteringMode()
      {
        return (MeteringMode)getObject(METERING_MODE);
      }

    public void setMeteringMode (final MeteringMode meteringMode)
      {
        setObject(METERING_MODE, meteringMode);
      }

    public static enum LightSource
       {
         UNKNOWN(0, "unknown"),
         DAYLIGHT(1, "Daylight"),
         FLUORESCENT(2, "Fluorescent"),
         TUNGSTEN(3, "Tungsten"),
         FLASH(4, "Flash"),
         FINE_WEATHER(9, "Fine weather"),
         CLOUDY_WEATHER(10, "Cloudy weather"),
         SHADE(11, "Shade"),
         DAYLIGHT_FLUORESCENT(12, "Daylight fluorescent"),
         DAY_WHITE_FLUORESCENT(13, "Day white fluorescent"),
         COOL_WHITE_FLUORESCENT(14, "Cool white fluorescent"),
         WHITE_FLUORESCENT(15, "White fluorescent"),
         STANDARD_LIGHT_A(17, "Standard light A"),
         STANDARD_LIGHT_B(18, "Standard light B"),
         STANDARD_LIGHT_C(19, "Standard light C"),
         D55(20, "D55"),
         D65(21, "D65"),
         D75(22, "D75"),
         D50(23, "D50"),
         ISO_STUDIO_TUNGSTEN(24, "ISO studio tungsten"),
         OTHER_LIGHT_SOURCE(255, "other light source"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private LightSource (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static LightSource fromInteger(int value)
           {
             if (value == (short)0) return UNKNOWN;
             if (value == (short)1) return DAYLIGHT;
             if (value == (short)2) return FLUORESCENT;
             if (value == (short)3) return TUNGSTEN;
             if (value == (short)4) return FLASH;
             if (value == (short)9) return FINE_WEATHER;
             if (value == (short)10) return CLOUDY_WEATHER;
             if (value == (short)11) return SHADE;
             if (value == (short)12) return DAYLIGHT_FLUORESCENT;
             if (value == (short)13) return DAY_WHITE_FLUORESCENT;
             if (value == (short)14) return COOL_WHITE_FLUORESCENT;
             if (value == (short)15) return WHITE_FLUORESCENT;
             if (value == (short)17) return STANDARD_LIGHT_A;
             if (value == (short)18) return STANDARD_LIGHT_B;
             if (value == (short)19) return STANDARD_LIGHT_C;
             if (value == (short)20) return D55;
             if (value == (short)21) return D65;
             if (value == (short)22) return D75;
             if (value == (short)23) return D50;
             if (value == (short)24) return ISO_STUDIO_TUNGSTEN;
             if (value == (short)255) return OTHER_LIGHT_SOURCE;

             return _UNKNOWN;
           }
       }
    public boolean isLightSourceAvailable()
      {
        return containsTag(LIGHT_SOURCE);
      }

    public void setLightSourceAvailable (final boolean available)
      {
        if (available && !containsTag(LIGHT_SOURCE))
          {
            setLightSource(null);
          }
        else if (!available)
          {
            removeTag(LIGHT_SOURCE);
          }
      }

    public LightSource getLightSource()
      {
        return (LightSource)getObject(LIGHT_SOURCE);
      }

    public void setLightSource (final LightSource lightSource)
      {
        setObject(LIGHT_SOURCE, lightSource);
      }

    public boolean isFlashAvailable()
      {
        return containsTag(FLASH);
      }

    public void setFlashAvailable (final boolean available)
      {
        if (available && !containsTag(FLASH))
          {
            setFlash(null);
          }
        else if (!available)
          {
            removeTag(FLASH);
          }
      }

    public Integer getFlash()
      {
        return (Integer)getObject(FLASH);
      }

    public void setFlash (final Integer flash)
      {
        setObject(FLASH, flash);
      }

    public boolean isFocalLengthAvailable()
      {
        return containsTag(FOCAL_LENGTH);
      }

    public void setFocalLengthAvailable (final boolean available)
      {
        if (available && !containsTag(FOCAL_LENGTH))
          {
            setFocalLength(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_LENGTH);
          }
      }

    public Rational getFocalLength()
      {
        return (Rational)getObject(FOCAL_LENGTH);
      }

    public void setFocalLength (final Rational focalLength)
      {
        setObject(FOCAL_LENGTH, focalLength);
      }

    public boolean isFlashEnergy2Available()
      {
        return containsTag(FLASH_ENERGY2);
      }

    public void setFlashEnergy2Available (final boolean available)
      {
        if (available && !containsTag(FLASH_ENERGY2))
          {
            setFlashEnergy2(null);
          }
        else if (!available)
          {
            removeTag(FLASH_ENERGY2);
          }
      }

    public Rational[] getFlashEnergy2()
      {
        return (Rational[])getObject(FLASH_ENERGY2);
      }

    public void setFlashEnergy2 (final Rational[] flashEnergy2)
      {
        setObject(FLASH_ENERGY2, flashEnergy2);
      }

    public boolean isSpatialFrequencyResponse2Available()
      {
        return containsTag(SPATIAL_FREQUENCYRESPONSE2);
      }

    public void setSpatialFrequencyResponse2Available (final boolean available)
      {
        if (available && !containsTag(SPATIAL_FREQUENCYRESPONSE2))
          {
            setSpatialFrequencyResponse2(null);
          }
        else if (!available)
          {
            removeTag(SPATIAL_FREQUENCYRESPONSE2);
          }
      }

    public byte[] getSpatialFrequencyResponse2()
      {
        return (byte[])getObject(SPATIAL_FREQUENCYRESPONSE2);
      }

    public void setSpatialFrequencyResponse2 (final byte[] spatialFrequencyResponse2)
      {
        setObject(SPATIAL_FREQUENCYRESPONSE2, spatialFrequencyResponse2);
      }

    public boolean isNoiseAvailable()
      {
        return containsTag(NOISE);
      }

    public void setNoiseAvailable (final boolean available)
      {
        if (available && !containsTag(NOISE))
          {
            setNoise(null);
          }
        else if (!available)
          {
            removeTag(NOISE);
          }
      }

    public byte[] getNoise()
      {
        return (byte[])getObject(NOISE);
      }

    public void setNoise (final byte[] noise)
      {
        setObject(NOISE, noise);
      }

    public boolean isFocalPlaneXResolution2Available()
      {
        return containsTag(FOCAL_PLANEXRESOLUTION2);
      }

    public void setFocalPlaneXResolution2Available (final boolean available)
      {
        if (available && !containsTag(FOCAL_PLANEXRESOLUTION2))
          {
            setFocalPlaneXResolution2(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_PLANEXRESOLUTION2);
          }
      }

    public Rational getFocalPlaneXResolution2()
      {
        return (Rational)getObject(FOCAL_PLANEXRESOLUTION2);
      }

    public void setFocalPlaneXResolution2 (final Rational focalPlaneXResolution2)
      {
        setObject(FOCAL_PLANEXRESOLUTION2, focalPlaneXResolution2);
      }

    public boolean isFocalPlaneYResolution2Available()
      {
        return containsTag(FOCAL_PLANEYRESOLUTION2);
      }

    public void setFocalPlaneYResolution2Available (final boolean available)
      {
        if (available && !containsTag(FOCAL_PLANEYRESOLUTION2))
          {
            setFocalPlaneYResolution2(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_PLANEYRESOLUTION2);
          }
      }

    public Rational getFocalPlaneYResolution2()
      {
        return (Rational)getObject(FOCAL_PLANEYRESOLUTION2);
      }

    public void setFocalPlaneYResolution2 (final Rational focalPlaneYResolution2)
      {
        setObject(FOCAL_PLANEYRESOLUTION2, focalPlaneYResolution2);
      }

    public boolean isFocalPlaneResolutionUnit2Available()
      {
        return containsTag(FOCAL_PLANERESOLUTIONUNIT2);
      }

    public void setFocalPlaneResolutionUnit2Available (final boolean available)
      {
        if (available && !containsTag(FOCAL_PLANERESOLUTIONUNIT2))
          {
            setFocalPlaneResolutionUnit2(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_PLANERESOLUTIONUNIT2);
          }
      }

    public Integer getFocalPlaneResolutionUnit2()
      {
        return (Integer)getObject(FOCAL_PLANERESOLUTIONUNIT2);
      }

    public void setFocalPlaneResolutionUnit2 (final Integer focalPlaneResolutionUnit2)
      {
        setObject(FOCAL_PLANERESOLUTIONUNIT2, focalPlaneResolutionUnit2);
      }

    public boolean isImageNumberAvailable()
      {
        return containsTag(IMAGE_NUMBER);
      }

    public void setImageNumberAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_NUMBER))
          {
            setImageNumber(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_NUMBER);
          }
      }

    public Long getImageNumber()
      {
        return (Long)getObject(IMAGE_NUMBER);
      }

    public void setImageNumber (final Long imageNumber)
      {
        setObject(IMAGE_NUMBER, imageNumber);
      }

    public boolean isSecurityClassificationAvailable()
      {
        return containsTag(SECURITY_CLASSIFICATION);
      }

    public void setSecurityClassificationAvailable (final boolean available)
      {
        if (available && !containsTag(SECURITY_CLASSIFICATION))
          {
            setSecurityClassification(null);
          }
        else if (!available)
          {
            removeTag(SECURITY_CLASSIFICATION);
          }
      }

    public String getSecurityClassification()
      {
        return (String)getObject(SECURITY_CLASSIFICATION);
      }

    public void setSecurityClassification (final String securityClassification)
      {
        setObject(SECURITY_CLASSIFICATION, securityClassification);
      }

    public boolean isImageHistoryAvailable()
      {
        return containsTag(IMAGE_HISTORY);
      }

    public void setImageHistoryAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_HISTORY))
          {
            setImageHistory(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_HISTORY);
          }
      }

    public String getImageHistory()
      {
        return (String)getObject(IMAGE_HISTORY);
      }

    public void setImageHistory (final String imageHistory)
      {
        setObject(IMAGE_HISTORY, imageHistory);
      }

    public boolean isSubjectAreaAvailable()
      {
        return containsTag(SUBJECT_AREA);
      }

    public void setSubjectAreaAvailable (final boolean available)
      {
        if (available && !containsTag(SUBJECT_AREA))
          {
            setSubjectArea(null);
          }
        else if (!available)
          {
            removeTag(SUBJECT_AREA);
          }
      }

    public int[] getSubjectArea()
      {
        return (int[])getObject(SUBJECT_AREA);
      }

    public void setSubjectArea (final int[] subjectArea)
      {
        setObject(SUBJECT_AREA, subjectArea);
      }

    public boolean isExposureIndex2Available()
      {
        return containsTag(EXPOSURE_INDEX_2);
      }

    public void setExposureIndex2Available (final boolean available)
      {
        if (available && !containsTag(EXPOSURE_INDEX_2))
          {
            setExposureIndex2(null);
          }
        else if (!available)
          {
            removeTag(EXPOSURE_INDEX_2);
          }
      }

    public Rational[] getExposureIndex2()
      {
        return (Rational[])getObject(EXPOSURE_INDEX_2);
      }

    public void setExposureIndex2 (final Rational[] exposureIndex2)
      {
        setObject(EXPOSURE_INDEX_2, exposureIndex2);
      }

    public boolean isTIFF_EPStandardIDAvailable()
      {
        return containsTag(TIFF_EP_STANDARD_ID);
      }

    public void setTIFF_EPStandardIDAvailable (final boolean available)
      {
        if (available && !containsTag(TIFF_EP_STANDARD_ID))
          {
            setTIFF_EPStandardID(null);
          }
        else if (!available)
          {
            removeTag(TIFF_EP_STANDARD_ID);
          }
      }

    public byte[] getTIFF_EPStandardID()
      {
        return (byte[])getObject(TIFF_EP_STANDARD_ID);
      }

    public void setTIFF_EPStandardID (final byte[] tIFF_EPStandardID)
      {
        setObject(TIFF_EP_STANDARD_ID, tIFF_EPStandardID);
      }

    public static enum SensingMethod2
       {
         NOT_DEFINED(1, "Not defined"),
         ONE_CHIP_COLOR_AREA_SENSOR(2, "One-chip color area sensor"),
         TWO_CHIP_COLOR_AREA_SENSOR(3, "Two-chip color area sensor"),
         THREE_CHIP_COLOR_AREA_SENSOR(4, "Three-chip color area sensor"),
         COLOR_SEQUENTIAL_AREA_SENSOR(5, "Color sequential area sensor"),
         TRILINEAR_SENSOR(7, "Trilinear sensor"),
         COLOR_SEQUENTIAL_LINEAR_SENSOR(8, "Color sequential linear sensor"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private SensingMethod2 (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static SensingMethod2 fromInteger(int value)
           {
             if (value == (short)1) return NOT_DEFINED;
             if (value == (short)2) return ONE_CHIP_COLOR_AREA_SENSOR;
             if (value == (short)3) return TWO_CHIP_COLOR_AREA_SENSOR;
             if (value == (short)4) return THREE_CHIP_COLOR_AREA_SENSOR;
             if (value == (short)5) return COLOR_SEQUENTIAL_AREA_SENSOR;
             if (value == (short)7) return TRILINEAR_SENSOR;
             if (value == (short)8) return COLOR_SEQUENTIAL_LINEAR_SENSOR;

             return _UNKNOWN;
           }
       }
    public boolean isSensingMethod2Available()
      {
        return containsTag(SENSING_METHOD_2);
      }

    public void setSensingMethod2Available (final boolean available)
      {
        if (available && !containsTag(SENSING_METHOD_2))
          {
            setSensingMethod2(null);
          }
        else if (!available)
          {
            removeTag(SENSING_METHOD_2);
          }
      }

    public SensingMethod2 getSensingMethod2()
      {
        return (SensingMethod2)getObject(SENSING_METHOD_2);
      }

    public void setSensingMethod2 (final SensingMethod2 sensingMethod2)
      {
        setObject(SENSING_METHOD_2, sensingMethod2);
      }

    public boolean isMakerNoteAvailable()
      {
        return containsTag(MAKER_NOTE);
      }

    public void setMakerNoteAvailable (final boolean available)
      {
        if (available && !containsTag(MAKER_NOTE))
          {
            setMakerNote(null);
          }
        else if (!available)
          {
            removeTag(MAKER_NOTE);
          }
      }

    public Long getMakerNote()
      {
        return (Long)getObject(MAKER_NOTE);
      }

    public void setMakerNote (final Long makerNote)
      {
        setObject(MAKER_NOTE, makerNote);
      }

    public boolean isUserCommentAvailable()
      {
        return containsTag(USER_COMMENT);
      }

    public void setUserCommentAvailable (final boolean available)
      {
        if (available && !containsTag(USER_COMMENT))
          {
            setUserComment(null);
          }
        else if (!available)
          {
            removeTag(USER_COMMENT);
          }
      }

    public byte[] getUserComment()
      {
        return (byte[])getObject(USER_COMMENT);
      }

    public void setUserComment (final byte[] userComment)
      {
        setObject(USER_COMMENT, userComment);
      }

    public boolean isSubsecTimeAvailable()
      {
        return containsTag(SUBSEC_TIME);
      }

    public void setSubsecTimeAvailable (final boolean available)
      {
        if (available && !containsTag(SUBSEC_TIME))
          {
            setSubsecTime(null);
          }
        else if (!available)
          {
            removeTag(SUBSEC_TIME);
          }
      }

    public String getSubsecTime()
      {
        return (String)getObject(SUBSEC_TIME);
      }

    public void setSubsecTime (final String subsecTime)
      {
        setObject(SUBSEC_TIME, subsecTime);
      }

    public boolean isSubsecTimeOriginalAvailable()
      {
        return containsTag(SUBSEC_TIME_ORIGINAL);
      }

    public void setSubsecTimeOriginalAvailable (final boolean available)
      {
        if (available && !containsTag(SUBSEC_TIME_ORIGINAL))
          {
            setSubsecTimeOriginal(null);
          }
        else if (!available)
          {
            removeTag(SUBSEC_TIME_ORIGINAL);
          }
      }

    public String getSubsecTimeOriginal()
      {
        return (String)getObject(SUBSEC_TIME_ORIGINAL);
      }

    public void setSubsecTimeOriginal (final String subsecTimeOriginal)
      {
        setObject(SUBSEC_TIME_ORIGINAL, subsecTimeOriginal);
      }

    public boolean isSubsecTimeDigitizedAvailable()
      {
        return containsTag(SUBSEC_TIME_DIGITIZED);
      }

    public void setSubsecTimeDigitizedAvailable (final boolean available)
      {
        if (available && !containsTag(SUBSEC_TIME_DIGITIZED))
          {
            setSubsecTimeDigitized(null);
          }
        else if (!available)
          {
            removeTag(SUBSEC_TIME_DIGITIZED);
          }
      }

    public String getSubsecTimeDigitized()
      {
        return (String)getObject(SUBSEC_TIME_DIGITIZED);
      }

    public void setSubsecTimeDigitized (final String subsecTimeDigitized)
      {
        setObject(SUBSEC_TIME_DIGITIZED, subsecTimeDigitized);
      }

    public boolean isImageSourceDataAvailable()
      {
        return containsTag(IMAGE_SOURCE_DATA);
      }

    public void setImageSourceDataAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_SOURCE_DATA))
          {
            setImageSourceData(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_SOURCE_DATA);
          }
      }

    public byte[] getImageSourceData()
      {
        return (byte[])getObject(IMAGE_SOURCE_DATA);
      }

    public void setImageSourceData (final byte[] imageSourceData)
      {
        setObject(IMAGE_SOURCE_DATA, imageSourceData);
      }

    public boolean isFlashPixVersionAvailable()
      {
        return containsTag(FLASHPIX_VERSION);
      }

    public void setFlashPixVersionAvailable (final boolean available)
      {
        if (available && !containsTag(FLASHPIX_VERSION))
          {
            setFlashPixVersion(null);
          }
        else if (!available)
          {
            removeTag(FLASHPIX_VERSION);
          }
      }

    public byte[] getFlashPixVersion()
      {
        return (byte[])getObject(FLASHPIX_VERSION);
      }

    public void setFlashPixVersion (final byte[] flashPixVersion)
      {
        setObject(FLASHPIX_VERSION, flashPixVersion);
      }

    public static enum ColorSpace
       {
         SRGB(1, "sRGB"),
         UNCALIBRATED(0xFFFF, "Uncalibrated"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private ColorSpace (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static ColorSpace fromInteger(int value)
           {
             if (value == (short)1) return SRGB;
             if (value == (short)0xFFFF) return UNCALIBRATED;

             return _UNKNOWN;
           }
       }
    public boolean isColorSpaceAvailable()
      {
        return containsTag(COLOR_SPACE);
      }

    public void setColorSpaceAvailable (final boolean available)
      {
        if (available && !containsTag(COLOR_SPACE))
          {
            setColorSpace(null);
          }
        else if (!available)
          {
            removeTag(COLOR_SPACE);
          }
      }

    public ColorSpace getColorSpace()
      {
        return (ColorSpace)getObject(COLOR_SPACE);
      }

    public void setColorSpace (final ColorSpace colorSpace)
      {
        setObject(COLOR_SPACE, colorSpace);
      }

    public boolean isPixelXDimensionAvailable()
      {
        return containsTag(PIXEL_X_DIMENSION);
      }

    public void setPixelXDimensionAvailable (final boolean available)
      {
        if (available && !containsTag(PIXEL_X_DIMENSION))
          {
            setPixelXDimension(null);
          }
        else if (!available)
          {
            removeTag(PIXEL_X_DIMENSION);
          }
      }

    public Integer getPixelXDimension()
      {
        return (Integer)getObject(PIXEL_X_DIMENSION);
      }

    public void setPixelXDimension (final Integer pixelXDimension)
      {
        setObject(PIXEL_X_DIMENSION, pixelXDimension);
      }

    public boolean isPixelYDimensionAvailable()
      {
        return containsTag(PIXEL_Y_DIMENSION);
      }

    public void setPixelYDimensionAvailable (final boolean available)
      {
        if (available && !containsTag(PIXEL_Y_DIMENSION))
          {
            setPixelYDimension(null);
          }
        else if (!available)
          {
            removeTag(PIXEL_Y_DIMENSION);
          }
      }

    public Integer getPixelYDimension()
      {
        return (Integer)getObject(PIXEL_Y_DIMENSION);
      }

    public void setPixelYDimension (final Integer pixelYDimension)
      {
        setObject(PIXEL_Y_DIMENSION, pixelYDimension);
      }

    public boolean isRelatedSoundFileAvailable()
      {
        return containsTag(RELATED_SOUND_FILE);
      }

    public void setRelatedSoundFileAvailable (final boolean available)
      {
        if (available && !containsTag(RELATED_SOUND_FILE))
          {
            setRelatedSoundFile(null);
          }
        else if (!available)
          {
            removeTag(RELATED_SOUND_FILE);
          }
      }

    public String getRelatedSoundFile()
      {
        return (String)getObject(RELATED_SOUND_FILE);
      }

    public void setRelatedSoundFile (final String relatedSoundFile)
      {
        setObject(RELATED_SOUND_FILE, relatedSoundFile);
      }

    public boolean isInteroperabilityIFDAvailable()
      {
        return containsTag(INTEROPERABILITY_IFD);
      }

    public void setInteroperabilityIFDAvailable (final boolean available)
      {
        if (available && !containsTag(INTEROPERABILITY_IFD))
          {
            setInteroperabilityIFD(null);
          }
        else if (!available)
          {
            removeTag(INTEROPERABILITY_IFD);
          }
      }

    public Long getInteroperabilityIFD()
      {
        return (Long)getObject(INTEROPERABILITY_IFD);
      }

    public void setInteroperabilityIFD (final Long interoperabilityIFD)
      {
        setObject(INTEROPERABILITY_IFD, interoperabilityIFD);
      }

    public boolean isFlashEnergyAvailable()
      {
        return containsTag(FLASH_ENERGY);
      }

    public void setFlashEnergyAvailable (final boolean available)
      {
        if (available && !containsTag(FLASH_ENERGY))
          {
            setFlashEnergy(null);
          }
        else if (!available)
          {
            removeTag(FLASH_ENERGY);
          }
      }

    public Rational getFlashEnergy()
      {
        return (Rational)getObject(FLASH_ENERGY);
      }

    public void setFlashEnergy (final Rational flashEnergy)
      {
        setObject(FLASH_ENERGY, flashEnergy);
      }

    public boolean isSpatialFrequencyResponseAvailable()
      {
        return containsTag(SPATIAL_FREQUENCY_RESPONSE);
      }

    public void setSpatialFrequencyResponseAvailable (final boolean available)
      {
        if (available && !containsTag(SPATIAL_FREQUENCY_RESPONSE))
          {
            setSpatialFrequencyResponse(null);
          }
        else if (!available)
          {
            removeTag(SPATIAL_FREQUENCY_RESPONSE);
          }
      }

    public byte[] getSpatialFrequencyResponse()
      {
        return (byte[])getObject(SPATIAL_FREQUENCY_RESPONSE);
      }

    public void setSpatialFrequencyResponse (final byte[] spatialFrequencyResponse)
      {
        setObject(SPATIAL_FREQUENCY_RESPONSE, spatialFrequencyResponse);
      }

    public boolean isFocalPlaneXResolutionAvailable()
      {
        return containsTag(FOCAL_PLANE_X_RESOLUTION);
      }

    public void setFocalPlaneXResolutionAvailable (final boolean available)
      {
        if (available && !containsTag(FOCAL_PLANE_X_RESOLUTION))
          {
            setFocalPlaneXResolution(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_PLANE_X_RESOLUTION);
          }
      }

    public Rational getFocalPlaneXResolution()
      {
        return (Rational)getObject(FOCAL_PLANE_X_RESOLUTION);
      }

    public void setFocalPlaneXResolution (final Rational focalPlaneXResolution)
      {
        setObject(FOCAL_PLANE_X_RESOLUTION, focalPlaneXResolution);
      }

    public boolean isFocalPlaneYResolutionAvailable()
      {
        return containsTag(FOCAL_PLANE_Y_RESOLUTION);
      }

    public void setFocalPlaneYResolutionAvailable (final boolean available)
      {
        if (available && !containsTag(FOCAL_PLANE_Y_RESOLUTION))
          {
            setFocalPlaneYResolution(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_PLANE_Y_RESOLUTION);
          }
      }

    public Rational getFocalPlaneYResolution()
      {
        return (Rational)getObject(FOCAL_PLANE_Y_RESOLUTION);
      }

    public void setFocalPlaneYResolution (final Rational focalPlaneYResolution)
      {
        setObject(FOCAL_PLANE_Y_RESOLUTION, focalPlaneYResolution);
      }

    public boolean isFocalPlaneResolutionUnitAvailable()
      {
        return containsTag(FOCAL_PLANE_RESOLUTIONUNIT);
      }

    public void setFocalPlaneResolutionUnitAvailable (final boolean available)
      {
        if (available && !containsTag(FOCAL_PLANE_RESOLUTIONUNIT))
          {
            setFocalPlaneResolutionUnit(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_PLANE_RESOLUTIONUNIT);
          }
      }

    public Integer getFocalPlaneResolutionUnit()
      {
        return (Integer)getObject(FOCAL_PLANE_RESOLUTIONUNIT);
      }

    public void setFocalPlaneResolutionUnit (final Integer focalPlaneResolutionUnit)
      {
        setObject(FOCAL_PLANE_RESOLUTIONUNIT, focalPlaneResolutionUnit);
      }

    public boolean isSubjectLocationAvailable()
      {
        return containsTag(SUBJECT_LOCATION);
      }

    public void setSubjectLocationAvailable (final boolean available)
      {
        if (available && !containsTag(SUBJECT_LOCATION))
          {
            setSubjectLocation(null);
          }
        else if (!available)
          {
            removeTag(SUBJECT_LOCATION);
          }
      }

    public int[] getSubjectLocation()
      {
        return (int[])getObject(SUBJECT_LOCATION);
      }

    public void setSubjectLocation (final int[] subjectLocation)
      {
        setObject(SUBJECT_LOCATION, subjectLocation);
      }

    public boolean isExposureIndexAvailable()
      {
        return containsTag(EXPOSURE_INDEX);
      }

    public void setExposureIndexAvailable (final boolean available)
      {
        if (available && !containsTag(EXPOSURE_INDEX))
          {
            setExposureIndex(null);
          }
        else if (!available)
          {
            removeTag(EXPOSURE_INDEX);
          }
      }

    public Rational getExposureIndex()
      {
        return (Rational)getObject(EXPOSURE_INDEX);
      }

    public void setExposureIndex (final Rational exposureIndex)
      {
        setObject(EXPOSURE_INDEX, exposureIndex);
      }

    public static enum SensingMethod
       {
         NOT_DEFINED(1, "not defined"),
         ONE_CHIP_COLOR_AREA_SENSOR(2, "one chip color area sensor"),
         TWO_CHIP_COLOR_AREA_SENSOR(3, "Two chip color area sensor"),
         THREE_CHIP_COLOR_AREA_SENSOR(4, "Three chip color area sensor"),
         COLOR_SEQUENTIAL_AREA_SENSOR(5, "Color sequential area sensor"),
         TRILINEAR_SENSOR(7, "Trilinear sensor"),
         COLOR_SEQUENTIAL_LINEAR_SENSOR(8, "Color sequential linear sensor"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private SensingMethod (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static SensingMethod fromInteger(int value)
           {
             if (value == (short)1) return NOT_DEFINED;
             if (value == (short)2) return ONE_CHIP_COLOR_AREA_SENSOR;
             if (value == (short)3) return TWO_CHIP_COLOR_AREA_SENSOR;
             if (value == (short)4) return THREE_CHIP_COLOR_AREA_SENSOR;
             if (value == (short)5) return COLOR_SEQUENTIAL_AREA_SENSOR;
             if (value == (short)7) return TRILINEAR_SENSOR;
             if (value == (short)8) return COLOR_SEQUENTIAL_LINEAR_SENSOR;

             return _UNKNOWN;
           }
       }
    public boolean isSensingMethodAvailable()
      {
        return containsTag(SENSING_METHOD);
      }

    public void setSensingMethodAvailable (final boolean available)
      {
        if (available && !containsTag(SENSING_METHOD))
          {
            setSensingMethod(null);
          }
        else if (!available)
          {
            removeTag(SENSING_METHOD);
          }
      }

    public SensingMethod getSensingMethod()
      {
        return (SensingMethod)getObject(SENSING_METHOD);
      }

    public void setSensingMethod (final SensingMethod sensingMethod)
      {
        setObject(SENSING_METHOD, sensingMethod);
      }

    public static enum FileSource
       {
         DSC(3, "dsc"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private FileSource (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static FileSource fromInteger(int value)
           {
             if (value == (byte)3) return DSC;

             return _UNKNOWN;
           }
       }
    public boolean isFileSourceAvailable()
      {
        return containsTag(FILE_SOURCE);
      }

    public void setFileSourceAvailable (final boolean available)
      {
        if (available && !containsTag(FILE_SOURCE))
          {
            setFileSource(null);
          }
        else if (!available)
          {
            removeTag(FILE_SOURCE);
          }
      }

    public FileSource getFileSource()
      {
        return (FileSource)getObject(FILE_SOURCE);
      }

    public void setFileSource (final FileSource fileSource)
      {
        setObject(FILE_SOURCE, fileSource);
      }

    public boolean isSceneTypeAvailable()
      {
        return containsTag(SCENE_TYPE);
      }

    public void setSceneTypeAvailable (final boolean available)
      {
        if (available && !containsTag(SCENE_TYPE))
          {
            setSceneType(null);
          }
        else if (!available)
          {
            removeTag(SCENE_TYPE);
          }
      }

    public Integer getSceneType()
      {
        return (Integer)getObject(SCENE_TYPE);
      }

    public void setSceneType (final Integer sceneType)
      {
        setObject(SCENE_TYPE, sceneType);
      }

    public boolean isEXIFCFAPatternAvailable()
      {
        return containsTag(EXIF_CFA_PATTERN);
      }

    public void setEXIFCFAPatternAvailable (final boolean available)
      {
        if (available && !containsTag(EXIF_CFA_PATTERN))
          {
            setEXIFCFAPattern(null);
          }
        else if (!available)
          {
            removeTag(EXIF_CFA_PATTERN);
          }
      }

    public byte[] getEXIFCFAPattern()
      {
        return (byte[])getObject(EXIF_CFA_PATTERN);
      }

    public void setEXIFCFAPattern (final byte[] eXIFCFAPattern)
      {
        setObject(EXIF_CFA_PATTERN, eXIFCFAPattern);
      }

    public static enum CustomRendered
       {
         NORMAL_PROCESS(0, "Normal process"),
         CUSTOM_PROCESS(1, "Custom process"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private CustomRendered (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static CustomRendered fromInteger(int value)
           {
             if (value == (short)0) return NORMAL_PROCESS;
             if (value == (short)1) return CUSTOM_PROCESS;

             return _UNKNOWN;
           }
       }
    public boolean isCustomRenderedAvailable()
      {
        return containsTag(CUSTOM_RENDERED);
      }

    public void setCustomRenderedAvailable (final boolean available)
      {
        if (available && !containsTag(CUSTOM_RENDERED))
          {
            setCustomRendered(null);
          }
        else if (!available)
          {
            removeTag(CUSTOM_RENDERED);
          }
      }

    public CustomRendered getCustomRendered()
      {
        return (CustomRendered)getObject(CUSTOM_RENDERED);
      }

    public void setCustomRendered (final CustomRendered customRendered)
      {
        setObject(CUSTOM_RENDERED, customRendered);
      }

    public static enum ExposureMode
       {
         AUTO(0, "auto"),
         MANUAL(1, "manual"),
         BRACKET(2, "bracket"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private ExposureMode (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static ExposureMode fromInteger(int value)
           {
             if (value == (short)0) return AUTO;
             if (value == (short)1) return MANUAL;
             if (value == (short)2) return BRACKET;

             return _UNKNOWN;
           }
       }
    public boolean isExposureModeAvailable()
      {
        return containsTag(EXPOSURE_MODE);
      }

    public void setExposureModeAvailable (final boolean available)
      {
        if (available && !containsTag(EXPOSURE_MODE))
          {
            setExposureMode(null);
          }
        else if (!available)
          {
            removeTag(EXPOSURE_MODE);
          }
      }

    public ExposureMode getExposureMode()
      {
        return (ExposureMode)getObject(EXPOSURE_MODE);
      }

    public void setExposureMode (final ExposureMode exposureMode)
      {
        setObject(EXPOSURE_MODE, exposureMode);
      }

    public static enum WhiteBalance
       {
         AUTO(0, "auto"),
         MANUAL(1, "manual"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private WhiteBalance (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static WhiteBalance fromInteger(int value)
           {
             if (value == (short)0) return AUTO;
             if (value == (short)1) return MANUAL;

             return _UNKNOWN;
           }
       }
    public boolean isWhiteBalanceAvailable()
      {
        return containsTag(WHITE_BALANCE);
      }

    public void setWhiteBalanceAvailable (final boolean available)
      {
        if (available && !containsTag(WHITE_BALANCE))
          {
            setWhiteBalance(null);
          }
        else if (!available)
          {
            removeTag(WHITE_BALANCE);
          }
      }

    public WhiteBalance getWhiteBalance()
      {
        return (WhiteBalance)getObject(WHITE_BALANCE);
      }

    public void setWhiteBalance (final WhiteBalance whiteBalance)
      {
        setObject(WHITE_BALANCE, whiteBalance);
      }

    public boolean isDigitalZoomRatioAvailable()
      {
        return containsTag(DIGITAL_ZOOM_RATIO);
      }

    public void setDigitalZoomRatioAvailable (final boolean available)
      {
        if (available && !containsTag(DIGITAL_ZOOM_RATIO))
          {
            setDigitalZoomRatio(null);
          }
        else if (!available)
          {
            removeTag(DIGITAL_ZOOM_RATIO);
          }
      }

    public Rational getDigitalZoomRatio()
      {
        return (Rational)getObject(DIGITAL_ZOOM_RATIO);
      }

    public void setDigitalZoomRatio (final Rational digitalZoomRatio)
      {
        setObject(DIGITAL_ZOOM_RATIO, digitalZoomRatio);
      }

    public boolean isFocalLength35mmFilmAvailable()
      {
        return containsTag(FOCAL_LENGTH_35MM_FILM);
      }

    public void setFocalLength35mmFilmAvailable (final boolean available)
      {
        if (available && !containsTag(FOCAL_LENGTH_35MM_FILM))
          {
            setFocalLength35mmFilm(null);
          }
        else if (!available)
          {
            removeTag(FOCAL_LENGTH_35MM_FILM);
          }
      }

    public Integer getFocalLength35mmFilm()
      {
        return (Integer)getObject(FOCAL_LENGTH_35MM_FILM);
      }

    public void setFocalLength35mmFilm (final Integer focalLength35mmFilm)
      {
        setObject(FOCAL_LENGTH_35MM_FILM, focalLength35mmFilm);
      }

    public boolean isSceneCaptureTypeAvailable()
      {
        return containsTag(SCENE_CAPTURE_TYPE);
      }

    public void setSceneCaptureTypeAvailable (final boolean available)
      {
        if (available && !containsTag(SCENE_CAPTURE_TYPE))
          {
            setSceneCaptureType(null);
          }
        else if (!available)
          {
            removeTag(SCENE_CAPTURE_TYPE);
          }
      }

    public Integer getSceneCaptureType()
      {
        return (Integer)getObject(SCENE_CAPTURE_TYPE);
      }

    public void setSceneCaptureType (final Integer sceneCaptureType)
      {
        setObject(SCENE_CAPTURE_TYPE, sceneCaptureType);
      }

    public static enum GainControl
       {
         NONE(0, "None"),
         LOW_GAIN_UP(1, "Low gain up"),
         HIGH_GAIN_UP(2, "High gain up"),
         LOW_GAIN_DOWN(3, "Low gain down"),
         HIGH_GAIN_DOWN(4, "High gain down"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private GainControl (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static GainControl fromInteger(int value)
           {
             if (value == (short)0) return NONE;
             if (value == (short)1) return LOW_GAIN_UP;
             if (value == (short)2) return HIGH_GAIN_UP;
             if (value == (short)3) return LOW_GAIN_DOWN;
             if (value == (short)4) return HIGH_GAIN_DOWN;

             return _UNKNOWN;
           }
       }
    public boolean isGainControlAvailable()
      {
        return containsTag(GAIN_CONTROL);
      }

    public void setGainControlAvailable (final boolean available)
      {
        if (available && !containsTag(GAIN_CONTROL))
          {
            setGainControl(null);
          }
        else if (!available)
          {
            removeTag(GAIN_CONTROL);
          }
      }

    public GainControl getGainControl()
      {
        return (GainControl)getObject(GAIN_CONTROL);
      }

    public void setGainControl (final GainControl gainControl)
      {
        setObject(GAIN_CONTROL, gainControl);
      }

    public static enum Contrast
       {
         NORMAL(0, "normal"),
         SOFT(1, "soft"),
         HARD(2, "hard"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private Contrast (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static Contrast fromInteger(int value)
           {
             if (value == (short)0) return NORMAL;
             if (value == (short)1) return SOFT;
             if (value == (short)2) return HARD;

             return _UNKNOWN;
           }
       }
    public boolean isContrastAvailable()
      {
        return containsTag(CONTRAST);
      }

    public void setContrastAvailable (final boolean available)
      {
        if (available && !containsTag(CONTRAST))
          {
            setContrast(null);
          }
        else if (!available)
          {
            removeTag(CONTRAST);
          }
      }

    public Contrast getContrast()
      {
        return (Contrast)getObject(CONTRAST);
      }

    public void setContrast (final Contrast contrast)
      {
        setObject(CONTRAST, contrast);
      }

    public static enum Saturation
       {
         NORMAL(0, "normal"),
         LOW(1, "low"),
         HIGH(2, "high"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private Saturation (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static Saturation fromInteger(int value)
           {
             if (value == (short)0) return NORMAL;
             if (value == (short)1) return LOW;
             if (value == (short)2) return HIGH;

             return _UNKNOWN;
           }
       }
    public boolean isSaturationAvailable()
      {
        return containsTag(SATURATION);
      }

    public void setSaturationAvailable (final boolean available)
      {
        if (available && !containsTag(SATURATION))
          {
            setSaturation(null);
          }
        else if (!available)
          {
            removeTag(SATURATION);
          }
      }

    public Saturation getSaturation()
      {
        return (Saturation)getObject(SATURATION);
      }

    public void setSaturation (final Saturation saturation)
      {
        setObject(SATURATION, saturation);
      }

    public static enum Sharpness
       {
         NORMAL(0, "normal"),
         SOFT(1, "soft"),
         HARD(2, "hard"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private Sharpness (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static Sharpness fromInteger(int value)
           {
             if (value == (short)0) return NORMAL;
             if (value == (short)1) return SOFT;
             if (value == (short)2) return HARD;

             return _UNKNOWN;
           }
       }
    public boolean isSharpnessAvailable()
      {
        return containsTag(SHARPNESS);
      }

    public void setSharpnessAvailable (final boolean available)
      {
        if (available && !containsTag(SHARPNESS))
          {
            setSharpness(null);
          }
        else if (!available)
          {
            removeTag(SHARPNESS);
          }
      }

    public Sharpness getSharpness()
      {
        return (Sharpness)getObject(SHARPNESS);
      }

    public void setSharpness (final Sharpness sharpness)
      {
        setObject(SHARPNESS, sharpness);
      }

    public boolean isDeviceSettingDescriptionAvailable()
      {
        return containsTag(DEVICE_SETTING_DESCRIPTION);
      }

    public void setDeviceSettingDescriptionAvailable (final boolean available)
      {
        if (available && !containsTag(DEVICE_SETTING_DESCRIPTION))
          {
            setDeviceSettingDescription(null);
          }
        else if (!available)
          {
            removeTag(DEVICE_SETTING_DESCRIPTION);
          }
      }

    public byte[] getDeviceSettingDescription()
      {
        return (byte[])getObject(DEVICE_SETTING_DESCRIPTION);
      }

    public void setDeviceSettingDescription (final byte[] deviceSettingDescription)
      {
        setObject(DEVICE_SETTING_DESCRIPTION, deviceSettingDescription);
      }

    public boolean isSubjectDistanceRangeAvailable()
      {
        return containsTag(SUBJECT_DISTANCE_RANGE);
      }

    public void setSubjectDistanceRangeAvailable (final boolean available)
      {
        if (available && !containsTag(SUBJECT_DISTANCE_RANGE))
          {
            setSubjectDistanceRange(null);
          }
        else if (!available)
          {
            removeTag(SUBJECT_DISTANCE_RANGE);
          }
      }

    public Integer getSubjectDistanceRange()
      {
        return (Integer)getObject(SUBJECT_DISTANCE_RANGE);
      }

    public void setSubjectDistanceRange (final Integer subjectDistanceRange)
      {
        setObject(SUBJECT_DISTANCE_RANGE, subjectDistanceRange);
      }

    public boolean isImageUniqueIDAvailable()
      {
        return containsTag(IMAGE_UNIQUE_ID);
      }

    public void setImageUniqueIDAvailable (final boolean available)
      {
        if (available && !containsTag(IMAGE_UNIQUE_ID))
          {
            setImageUniqueID(null);
          }
        else if (!available)
          {
            removeTag(IMAGE_UNIQUE_ID);
          }
      }

    public String getImageUniqueID()
      {
        return (String)getObject(IMAGE_UNIQUE_ID);
      }

    public void setImageUniqueID (final String imageUniqueID)
      {
        setObject(IMAGE_UNIQUE_ID, imageUniqueID);
      }

    public boolean isPhotoshopAnnotationsAvailable()
      {
        return containsTag(PHOTOSHOP_ANNOTATIONS);
      }

    public void setPhotoshopAnnotationsAvailable (final boolean available)
      {
        if (available && !containsTag(PHOTOSHOP_ANNOTATIONS))
          {
            setPhotoshopAnnotations(null);
          }
        else if (!available)
          {
            removeTag(PHOTOSHOP_ANNOTATIONS);
          }
      }

    public Integer getPhotoshopAnnotations()
      {
        return (Integer)getObject(PHOTOSHOP_ANNOTATIONS);
      }

    public void setPhotoshopAnnotations (final Integer photoshopAnnotations)
      {
        setObject(PHOTOSHOP_ANNOTATIONS, photoshopAnnotations);
      }

    public boolean isThumbnailAvailable()
      {
        return containsTag(THUMBNAIL);
      }

    public void setThumbnailAvailable (final boolean available)
      {
        if (available && !containsTag(THUMBNAIL))
          {
            setThumbnail(null);
          }
        else if (!available)
          {
            removeTag(THUMBNAIL);
          }
      }

    public byte[] getThumbnail()
      {
        return (byte[])getObject(THUMBNAIL);
      }

    public void setThumbnail (final byte[] thumbnail)
      {
        setObject(THUMBNAIL, thumbnail);
      }

    public boolean isDNGVersionAvailable()
      {
        return containsTag(DNG_VERSION);
      }

    public void setDNGVersionAvailable (final boolean available)
      {
        if (available && !containsTag(DNG_VERSION))
          {
            setDNGVersion(null);
          }
        else if (!available)
          {
            removeTag(DNG_VERSION);
          }
      }

    public byte[] getDNGVersion()
      {
        return (byte[])getObject(DNG_VERSION);
      }

    public void setDNGVersion (final byte[] dNGVersion)
      {
        setObject(DNG_VERSION, dNGVersion);
      }

    public boolean isDNGBackwardVersionAvailable()
      {
        return containsTag(DNG_BACKWARD_VERSION);
      }

    public void setDNGBackwardVersionAvailable (final boolean available)
      {
        if (available && !containsTag(DNG_BACKWARD_VERSION))
          {
            setDNGBackwardVersion(null);
          }
        else if (!available)
          {
            removeTag(DNG_BACKWARD_VERSION);
          }
      }

    public byte[] getDNGBackwardVersion()
      {
        return (byte[])getObject(DNG_BACKWARD_VERSION);
      }

    public void setDNGBackwardVersion (final byte[] dNGBackwardVersion)
      {
        setObject(DNG_BACKWARD_VERSION, dNGBackwardVersion);
      }

    public boolean isUniqueCameraModelAvailable()
      {
        return containsTag(UNIQUE_CAMERA_MODEL);
      }

    public void setUniqueCameraModelAvailable (final boolean available)
      {
        if (available && !containsTag(UNIQUE_CAMERA_MODEL))
          {
            setUniqueCameraModel(null);
          }
        else if (!available)
          {
            removeTag(UNIQUE_CAMERA_MODEL);
          }
      }

    public String getUniqueCameraModel()
      {
        return (String)getObject(UNIQUE_CAMERA_MODEL);
      }

    public void setUniqueCameraModel (final String uniqueCameraModel)
      {
        setObject(UNIQUE_CAMERA_MODEL, uniqueCameraModel);
      }

    public boolean isLocalizedCameraModelAvailable()
      {
        return containsTag(LOCALIZED_CAMERA_MODEL);
      }

    public void setLocalizedCameraModelAvailable (final boolean available)
      {
        if (available && !containsTag(LOCALIZED_CAMERA_MODEL))
          {
            setLocalizedCameraModel(null);
          }
        else if (!available)
          {
            removeTag(LOCALIZED_CAMERA_MODEL);
          }
      }

    public String getLocalizedCameraModel()
      {
        return (String)getObject(LOCALIZED_CAMERA_MODEL);
      }

    public void setLocalizedCameraModel (final String localizedCameraModel)
      {
        setObject(LOCALIZED_CAMERA_MODEL, localizedCameraModel);
      }

    public boolean isCFAPlaneColorAvailable()
      {
        return containsTag(CFA_PLANE_COLOR);
      }

    public void setCFAPlaneColorAvailable (final boolean available)
      {
        if (available && !containsTag(CFA_PLANE_COLOR))
          {
            setCFAPlaneColor(null);
          }
        else if (!available)
          {
            removeTag(CFA_PLANE_COLOR);
          }
      }

    public byte[] getCFAPlaneColor()
      {
        return (byte[])getObject(CFA_PLANE_COLOR);
      }

    public void setCFAPlaneColor (final byte[] cFAPlaneColor)
      {
        setObject(CFA_PLANE_COLOR, cFAPlaneColor);
      }

    public boolean isCFALayoutAvailable()
      {
        return containsTag(CFA_LAYOUT);
      }

    public void setCFALayoutAvailable (final boolean available)
      {
        if (available && !containsTag(CFA_LAYOUT))
          {
            setCFALayout(null);
          }
        else if (!available)
          {
            removeTag(CFA_LAYOUT);
          }
      }

    public Integer getCFALayout()
      {
        return (Integer)getObject(CFA_LAYOUT);
      }

    public void setCFALayout (final Integer cFALayout)
      {
        setObject(CFA_LAYOUT, cFALayout);
      }

    public boolean isLinearizationTableAvailable()
      {
        return containsTag(LINEARIZATION_TABLE);
      }

    public void setLinearizationTableAvailable (final boolean available)
      {
        if (available && !containsTag(LINEARIZATION_TABLE))
          {
            setLinearizationTable(null);
          }
        else if (!available)
          {
            removeTag(LINEARIZATION_TABLE);
          }
      }

    public int[] getLinearizationTable()
      {
        return (int[])getObject(LINEARIZATION_TABLE);
      }

    public void setLinearizationTable (final int[] linearizationTable)
      {
        setObject(LINEARIZATION_TABLE, linearizationTable);
      }

    public boolean isBlackLevelRepeatDimAvailable()
      {
        return containsTag(BLACK_LEVEL_REPEAT_DIM);
      }

    public void setBlackLevelRepeatDimAvailable (final boolean available)
      {
        if (available && !containsTag(BLACK_LEVEL_REPEAT_DIM))
          {
            setBlackLevelRepeatDim(null);
          }
        else if (!available)
          {
            removeTag(BLACK_LEVEL_REPEAT_DIM);
          }
      }

    public int[] getBlackLevelRepeatDim()
      {
        return (int[])getObject(BLACK_LEVEL_REPEAT_DIM);
      }

    public void setBlackLevelRepeatDim (final int[] blackLevelRepeatDim)
      {
        setObject(BLACK_LEVEL_REPEAT_DIM, blackLevelRepeatDim);
      }

    public boolean isBlackLevelAvailable()
      {
        return containsTag(BLACK_LEVEL);
      }

    public void setBlackLevelAvailable (final boolean available)
      {
        if (available && !containsTag(BLACK_LEVEL))
          {
            setBlackLevel(null);
          }
        else if (!available)
          {
            removeTag(BLACK_LEVEL);
          }
      }

    public Rational[] getBlackLevel()
      {
        return (Rational[])getObject(BLACK_LEVEL);
      }

    public void setBlackLevel (final Rational[] blackLevel)
      {
        setObject(BLACK_LEVEL, blackLevel);
      }

    public boolean isBlackLevelDeltaHAvailable()
      {
        return containsTag(BLACK_LEVEL_DELTA_H);
      }

    public void setBlackLevelDeltaHAvailable (final boolean available)
      {
        if (available && !containsTag(BLACK_LEVEL_DELTA_H))
          {
            setBlackLevelDeltaH(null);
          }
        else if (!available)
          {
            removeTag(BLACK_LEVEL_DELTA_H);
          }
      }

    public Rational[] getBlackLevelDeltaH()
      {
        return (Rational[])getObject(BLACK_LEVEL_DELTA_H);
      }

    public void setBlackLevelDeltaH (final Rational[] blackLevelDeltaH)
      {
        setObject(BLACK_LEVEL_DELTA_H, blackLevelDeltaH);
      }

    public boolean isBlackLevelDeltaVAvailable()
      {
        return containsTag(BLACK_LEVEL_DELTA_V);
      }

    public void setBlackLevelDeltaVAvailable (final boolean available)
      {
        if (available && !containsTag(BLACK_LEVEL_DELTA_V))
          {
            setBlackLevelDeltaV(null);
          }
        else if (!available)
          {
            removeTag(BLACK_LEVEL_DELTA_V);
          }
      }

    public Rational[] getBlackLevelDeltaV()
      {
        return (Rational[])getObject(BLACK_LEVEL_DELTA_V);
      }

    public void setBlackLevelDeltaV (final Rational[] blackLevelDeltaV)
      {
        setObject(BLACK_LEVEL_DELTA_V, blackLevelDeltaV);
      }

    public boolean isWhiteLevelAvailable()
      {
        return containsTag(WHITE_LEVEL);
      }

    public void setWhiteLevelAvailable (final boolean available)
      {
        if (available && !containsTag(WHITE_LEVEL))
          {
            setWhiteLevel(null);
          }
        else if (!available)
          {
            removeTag(WHITE_LEVEL);
          }
      }

    public int[] getWhiteLevel()
      {
        return (int[])getObject(WHITE_LEVEL);
      }

    public void setWhiteLevel (final int[] whiteLevel)
      {
        setObject(WHITE_LEVEL, whiteLevel);
      }

    public boolean isDefaultScaleAvailable()
      {
        return containsTag(DEFAULT_SCALE);
      }

    public void setDefaultScaleAvailable (final boolean available)
      {
        if (available && !containsTag(DEFAULT_SCALE))
          {
            setDefaultScale(null);
          }
        else if (!available)
          {
            removeTag(DEFAULT_SCALE);
          }
      }

    public Rational[] getDefaultScale()
      {
        return (Rational[])getObject(DEFAULT_SCALE);
      }

    public void setDefaultScale (final Rational[] defaultScale)
      {
        setObject(DEFAULT_SCALE, defaultScale);
      }

    public boolean isBestQualityScaleAvailable()
      {
        return containsTag(BEST_QUALITY_SCALE);
      }

    public void setBestQualityScaleAvailable (final boolean available)
      {
        if (available && !containsTag(BEST_QUALITY_SCALE))
          {
            setBestQualityScale(null);
          }
        else if (!available)
          {
            removeTag(BEST_QUALITY_SCALE);
          }
      }

    public Rational getBestQualityScale()
      {
        return (Rational)getObject(BEST_QUALITY_SCALE);
      }

    public void setBestQualityScale (final Rational bestQualityScale)
      {
        setObject(BEST_QUALITY_SCALE, bestQualityScale);
      }

    public boolean isDefaultCropOriginAvailable()
      {
        return containsTag(DEFAULT_CROP_ORIGIN);
      }

    public void setDefaultCropOriginAvailable (final boolean available)
      {
        if (available && !containsTag(DEFAULT_CROP_ORIGIN))
          {
            setDefaultCropOrigin(null);
          }
        else if (!available)
          {
            removeTag(DEFAULT_CROP_ORIGIN);
          }
      }

    public Rational[] getDefaultCropOrigin()
      {
        return (Rational[])getObject(DEFAULT_CROP_ORIGIN);
      }

    public void setDefaultCropOrigin (final Rational[] defaultCropOrigin)
      {
        setObject(DEFAULT_CROP_ORIGIN, defaultCropOrigin);
      }

    public boolean isDefaultCropSizeAvailable()
      {
        return containsTag(DEFAULT_CROP_SIZE);
      }

    public void setDefaultCropSizeAvailable (final boolean available)
      {
        if (available && !containsTag(DEFAULT_CROP_SIZE))
          {
            setDefaultCropSize(null);
          }
        else if (!available)
          {
            removeTag(DEFAULT_CROP_SIZE);
          }
      }

    public Rational[] getDefaultCropSize()
      {
        return (Rational[])getObject(DEFAULT_CROP_SIZE);
      }

    public void setDefaultCropSize (final Rational[] defaultCropSize)
      {
        setObject(DEFAULT_CROP_SIZE, defaultCropSize);
      }

    public static enum CalibrationIlluminant1
       {
         UNKNOWN(0, "unknown"),
         DAYLIGHT(1, "Daylight"),
         FLUORESCENT(2, "Fluorescent"),
         TUNGSTEN(3, "Tungsten"),
         FLASH(4, "Flash"),
         FINE_WEATHER(9, "Fine weather"),
         CLOUDY_WEATHER(10, "Cloudy weather"),
         SHADE(11, "Shade"),
         DAYLIGHT_FLUORESCENT(12, "Daylight fluorescent"),
         DAY_WHITE_FLUORESCENT(13, "Day white fluorescent"),
         COOL_WHITE_FLUORESCENT(14, "Cool white fluorescent"),
         WHITE_FLUORESCENT(15, "White fluorescent"),
         STANDARD_LIGHT_A(17, "Standard light A"),
         STANDARD_LIGHT_B(18, "Standard light B"),
         STANDARD_LIGHT_C(19, "Standard light C"),
         D55(20, "D55"),
         D65(21, "D65"),
         D75(22, "D75"),
         D50(23, "D50"),
         ISO_STUDIO_TUNGSTEN(24, "ISO studio tungsten"),
         OTHER_LIGHT_SOURCE(255, "other light source"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private CalibrationIlluminant1 (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static CalibrationIlluminant1 fromInteger(int value)
           {
             if (value == (short)0) return UNKNOWN;
             if (value == (short)1) return DAYLIGHT;
             if (value == (short)2) return FLUORESCENT;
             if (value == (short)3) return TUNGSTEN;
             if (value == (short)4) return FLASH;
             if (value == (short)9) return FINE_WEATHER;
             if (value == (short)10) return CLOUDY_WEATHER;
             if (value == (short)11) return SHADE;
             if (value == (short)12) return DAYLIGHT_FLUORESCENT;
             if (value == (short)13) return DAY_WHITE_FLUORESCENT;
             if (value == (short)14) return COOL_WHITE_FLUORESCENT;
             if (value == (short)15) return WHITE_FLUORESCENT;
             if (value == (short)17) return STANDARD_LIGHT_A;
             if (value == (short)18) return STANDARD_LIGHT_B;
             if (value == (short)19) return STANDARD_LIGHT_C;
             if (value == (short)20) return D55;
             if (value == (short)21) return D65;
             if (value == (short)22) return D75;
             if (value == (short)23) return D50;
             if (value == (short)24) return ISO_STUDIO_TUNGSTEN;
             if (value == (short)255) return OTHER_LIGHT_SOURCE;

             return _UNKNOWN;
           }
       }
    public boolean isCalibrationIlluminant1Available()
      {
        return containsTag(CALIBRATION_ILLUMINANT_1);
      }

    public void setCalibrationIlluminant1Available (final boolean available)
      {
        if (available && !containsTag(CALIBRATION_ILLUMINANT_1))
          {
            setCalibrationIlluminant1(null);
          }
        else if (!available)
          {
            removeTag(CALIBRATION_ILLUMINANT_1);
          }
      }

    public CalibrationIlluminant1 getCalibrationIlluminant1()
      {
        return (CalibrationIlluminant1)getObject(CALIBRATION_ILLUMINANT_1);
      }

    public void setCalibrationIlluminant1 (final CalibrationIlluminant1 calibrationIlluminant1)
      {
        setObject(CALIBRATION_ILLUMINANT_1, calibrationIlluminant1);
      }

    public static enum CalibrationIlluminant2
       {
         UNKNOWN(0, "unknown"),
         DAYLIGHT(1, "Daylight"),
         FLUORESCENT(2, "Fluorescent"),
         TUNGSTEN(3, "Tungsten"),
         FLASH(4, "Flash"),
         FINE_WEATHER(9, "Fine weather"),
         CLOUDY_WEATHER(10, "Cloudy weather"),
         SHADE(11, "Shade"),
         DAYLIGHT_FLUORESCENT(12, "Daylight fluorescent"),
         DAY_WHITE_FLUORESCENT(13, "Day white fluorescent"),
         COOL_WHITE_FLUORESCENT(14, "Cool white fluorescent"),
         WHITE_FLUORESCENT(15, "White fluorescent"),
         STANDARD_LIGHT_A(17, "Standard light A"),
         STANDARD_LIGHT_B(18, "Standard light B"),
         STANDARD_LIGHT_C(19, "Standard light C"),
         D55(20, "D55"),
         D65(21, "D65"),
         D75(22, "D75"),
         D50(23, "D50"),
         ISO_STUDIO_TUNGSTEN(24, "ISO studio tungsten"),
         OTHER_LIGHT_SOURCE(255, "other light source"),
         _UNKNOWN(-1, "_unknown_");
         private final static long serialVersionUID = 3059468666726854749L;
         private int value;
         private String name;

         private CalibrationIlluminant2 (int value, String name)
           {
             this.value = value;
             this.name = name;
           }

         public int getValue()
           {
             return value;
           }

         public static CalibrationIlluminant2 fromInteger(int value)
           {
             if (value == (short)0) return UNKNOWN;
             if (value == (short)1) return DAYLIGHT;
             if (value == (short)2) return FLUORESCENT;
             if (value == (short)3) return TUNGSTEN;
             if (value == (short)4) return FLASH;
             if (value == (short)9) return FINE_WEATHER;
             if (value == (short)10) return CLOUDY_WEATHER;
             if (value == (short)11) return SHADE;
             if (value == (short)12) return DAYLIGHT_FLUORESCENT;
             if (value == (short)13) return DAY_WHITE_FLUORESCENT;
             if (value == (short)14) return COOL_WHITE_FLUORESCENT;
             if (value == (short)15) return WHITE_FLUORESCENT;
             if (value == (short)17) return STANDARD_LIGHT_A;
             if (value == (short)18) return STANDARD_LIGHT_B;
             if (value == (short)19) return STANDARD_LIGHT_C;
             if (value == (short)20) return D55;
             if (value == (short)21) return D65;
             if (value == (short)22) return D75;
             if (value == (short)23) return D50;
             if (value == (short)24) return ISO_STUDIO_TUNGSTEN;
             if (value == (short)255) return OTHER_LIGHT_SOURCE;

             return _UNKNOWN;
           }
       }
    public boolean isCalibrationIlluminant2Available()
      {
        return containsTag(CALIBRATION_ILLUMINANT_2);
      }

    public void setCalibrationIlluminant2Available (final boolean available)
      {
        if (available && !containsTag(CALIBRATION_ILLUMINANT_2))
          {
            setCalibrationIlluminant2(null);
          }
        else if (!available)
          {
            removeTag(CALIBRATION_ILLUMINANT_2);
          }
      }

    public CalibrationIlluminant2 getCalibrationIlluminant2()
      {
        return (CalibrationIlluminant2)getObject(CALIBRATION_ILLUMINANT_2);
      }

    public void setCalibrationIlluminant2 (final CalibrationIlluminant2 calibrationIlluminant2)
      {
        setObject(CALIBRATION_ILLUMINANT_2, calibrationIlluminant2);
      }

    public boolean isColorMatrix1Available()
      {
        return containsTag(COLOR_MATRIX_1);
      }

    public void setColorMatrix1Available (final boolean available)
      {
        if (available && !containsTag(COLOR_MATRIX_1))
          {
            setColorMatrix1(null);
          }
        else if (!available)
          {
            removeTag(COLOR_MATRIX_1);
          }
      }

    public Rational[] getColorMatrix1()
      {
        return (Rational[])getObject(COLOR_MATRIX_1);
      }

    public void setColorMatrix1 (final Rational[] colorMatrix1)
      {
        setObject(COLOR_MATRIX_1, colorMatrix1);
      }

    public boolean isColorMatrix2Available()
      {
        return containsTag(COLOR_MATRIX_2);
      }

    public void setColorMatrix2Available (final boolean available)
      {
        if (available && !containsTag(COLOR_MATRIX_2))
          {
            setColorMatrix2(null);
          }
        else if (!available)
          {
            removeTag(COLOR_MATRIX_2);
          }
      }

    public Rational[] getColorMatrix2()
      {
        return (Rational[])getObject(COLOR_MATRIX_2);
      }

    public void setColorMatrix2 (final Rational[] colorMatrix2)
      {
        setObject(COLOR_MATRIX_2, colorMatrix2);
      }

    public boolean isCameraCalibration1Available()
      {
        return containsTag(CAMERA_CALIBRATION_1);
      }

    public void setCameraCalibration1Available (final boolean available)
      {
        if (available && !containsTag(CAMERA_CALIBRATION_1))
          {
            setCameraCalibration1(null);
          }
        else if (!available)
          {
            removeTag(CAMERA_CALIBRATION_1);
          }
      }

    public Rational[] getCameraCalibration1()
      {
        return (Rational[])getObject(CAMERA_CALIBRATION_1);
      }

    public void setCameraCalibration1 (final Rational[] cameraCalibration1)
      {
        setObject(CAMERA_CALIBRATION_1, cameraCalibration1);
      }

    public boolean isCameraCalibration2Available()
      {
        return containsTag(CAMERA_CALIBRATION_2);
      }

    public void setCameraCalibration2Available (final boolean available)
      {
        if (available && !containsTag(CAMERA_CALIBRATION_2))
          {
            setCameraCalibration2(null);
          }
        else if (!available)
          {
            removeTag(CAMERA_CALIBRATION_2);
          }
      }

    public Rational[] getCameraCalibration2()
      {
        return (Rational[])getObject(CAMERA_CALIBRATION_2);
      }

    public void setCameraCalibration2 (final Rational[] cameraCalibration2)
      {
        setObject(CAMERA_CALIBRATION_2, cameraCalibration2);
      }

    public boolean isReductionMatrix1Available()
      {
        return containsTag(REDUCTION_MATRIX_1);
      }

    public void setReductionMatrix1Available (final boolean available)
      {
        if (available && !containsTag(REDUCTION_MATRIX_1))
          {
            setReductionMatrix1(null);
          }
        else if (!available)
          {
            removeTag(REDUCTION_MATRIX_1);
          }
      }

    public Rational[] getReductionMatrix1()
      {
        return (Rational[])getObject(REDUCTION_MATRIX_1);
      }

    public void setReductionMatrix1 (final Rational[] reductionMatrix1)
      {
        setObject(REDUCTION_MATRIX_1, reductionMatrix1);
      }

    public boolean isReductionMatrix2Available()
      {
        return containsTag(REDUCTION_MATRIX_2);
      }

    public void setReductionMatrix2Available (final boolean available)
      {
        if (available && !containsTag(REDUCTION_MATRIX_2))
          {
            setReductionMatrix2(null);
          }
        else if (!available)
          {
            removeTag(REDUCTION_MATRIX_2);
          }
      }

    public Rational[] getReductionMatrix2()
      {
        return (Rational[])getObject(REDUCTION_MATRIX_2);
      }

    public void setReductionMatrix2 (final Rational[] reductionMatrix2)
      {
        setObject(REDUCTION_MATRIX_2, reductionMatrix2);
      }

    public boolean isAnalogBalanceAvailable()
      {
        return containsTag(ANALOG_BALANCE);
      }

    public void setAnalogBalanceAvailable (final boolean available)
      {
        if (available && !containsTag(ANALOG_BALANCE))
          {
            setAnalogBalance(null);
          }
        else if (!available)
          {
            removeTag(ANALOG_BALANCE);
          }
      }

    public Rational[] getAnalogBalance()
      {
        return (Rational[])getObject(ANALOG_BALANCE);
      }

    public void setAnalogBalance (final Rational[] analogBalance)
      {
        setObject(ANALOG_BALANCE, analogBalance);
      }

    public boolean isAsShotNeutralAvailable()
      {
        return containsTag(AS_SHOT_NEUTRAL);
      }

    public void setAsShotNeutralAvailable (final boolean available)
      {
        if (available && !containsTag(AS_SHOT_NEUTRAL))
          {
            setAsShotNeutral(null);
          }
        else if (!available)
          {
            removeTag(AS_SHOT_NEUTRAL);
          }
      }

    public Rational[] getAsShotNeutral()
      {
        return (Rational[])getObject(AS_SHOT_NEUTRAL);
      }

    public void setAsShotNeutral (final Rational[] asShotNeutral)
      {
        setObject(AS_SHOT_NEUTRAL, asShotNeutral);
      }

    public boolean isAsShotWhiteXYAvailable()
      {
        return containsTag(AS_SHOT_WHITE_XY);
      }

    public void setAsShotWhiteXYAvailable (final boolean available)
      {
        if (available && !containsTag(AS_SHOT_WHITE_XY))
          {
            setAsShotWhiteXY(null);
          }
        else if (!available)
          {
            removeTag(AS_SHOT_WHITE_XY);
          }
      }

    public Rational[] getAsShotWhiteXY()
      {
        return (Rational[])getObject(AS_SHOT_WHITE_XY);
      }

    public void setAsShotWhiteXY (final Rational[] asShotWhiteXY)
      {
        setObject(AS_SHOT_WHITE_XY, asShotWhiteXY);
      }

    public boolean isBaselineExposureAvailable()
      {
        return containsTag(BASELINE_EXPOSURE);
      }

    public void setBaselineExposureAvailable (final boolean available)
      {
        if (available && !containsTag(BASELINE_EXPOSURE))
          {
            setBaselineExposure(null);
          }
        else if (!available)
          {
            removeTag(BASELINE_EXPOSURE);
          }
      }

    public Rational getBaselineExposure()
      {
        return (Rational)getObject(BASELINE_EXPOSURE);
      }

    public void setBaselineExposure (final Rational baselineExposure)
      {
        setObject(BASELINE_EXPOSURE, baselineExposure);
      }

    public boolean isBaselineNoiseAvailable()
      {
        return containsTag(BASELINE_NOISE);
      }

    public void setBaselineNoiseAvailable (final boolean available)
      {
        if (available && !containsTag(BASELINE_NOISE))
          {
            setBaselineNoise(null);
          }
        else if (!available)
          {
            removeTag(BASELINE_NOISE);
          }
      }

    public Rational getBaselineNoise()
      {
        return (Rational)getObject(BASELINE_NOISE);
      }

    public void setBaselineNoise (final Rational baselineNoise)
      {
        setObject(BASELINE_NOISE, baselineNoise);
      }

    public boolean isBaselineSharpnessAvailable()
      {
        return containsTag(BASELINE_SHARPNESS);
      }

    public void setBaselineSharpnessAvailable (final boolean available)
      {
        if (available && !containsTag(BASELINE_SHARPNESS))
          {
            setBaselineSharpness(null);
          }
        else if (!available)
          {
            removeTag(BASELINE_SHARPNESS);
          }
      }

    public Rational getBaselineSharpness()
      {
        return (Rational)getObject(BASELINE_SHARPNESS);
      }

    public void setBaselineSharpness (final Rational baselineSharpness)
      {
        setObject(BASELINE_SHARPNESS, baselineSharpness);
      }

    public boolean isBayerGreenSplitAvailable()
      {
        return containsTag(BAYER_GREEN_SPLIT);
      }

    public void setBayerGreenSplitAvailable (final boolean available)
      {
        if (available && !containsTag(BAYER_GREEN_SPLIT))
          {
            setBayerGreenSplit(null);
          }
        else if (!available)
          {
            removeTag(BAYER_GREEN_SPLIT);
          }
      }

    public Long getBayerGreenSplit()
      {
        return (Long)getObject(BAYER_GREEN_SPLIT);
      }

    public void setBayerGreenSplit (final Long bayerGreenSplit)
      {
        setObject(BAYER_GREEN_SPLIT, bayerGreenSplit);
      }

    public boolean isLinearResponseLimitAvailable()
      {
        return containsTag(LINEAR_RESPONSE_LIMIT);
      }

    public void setLinearResponseLimitAvailable (final boolean available)
      {
        if (available && !containsTag(LINEAR_RESPONSE_LIMIT))
          {
            setLinearResponseLimit(null);
          }
        else if (!available)
          {
            removeTag(LINEAR_RESPONSE_LIMIT);
          }
      }

    public Rational getLinearResponseLimit()
      {
        return (Rational)getObject(LINEAR_RESPONSE_LIMIT);
      }

    public void setLinearResponseLimit (final Rational linearResponseLimit)
      {
        setObject(LINEAR_RESPONSE_LIMIT, linearResponseLimit);
      }

    public boolean isCameraSerialNumberAvailable()
      {
        return containsTag(CAMERA_SERIAL_NUMBER);
      }

    public void setCameraSerialNumberAvailable (final boolean available)
      {
        if (available && !containsTag(CAMERA_SERIAL_NUMBER))
          {
            setCameraSerialNumber(null);
          }
        else if (!available)
          {
            removeTag(CAMERA_SERIAL_NUMBER);
          }
      }

    public String getCameraSerialNumber()
      {
        return (String)getObject(CAMERA_SERIAL_NUMBER);
      }

    public void setCameraSerialNumber (final String cameraSerialNumber)
      {
        setObject(CAMERA_SERIAL_NUMBER, cameraSerialNumber);
      }

    public boolean isLensInfoAvailable()
      {
        return containsTag(LENS_INFO);
      }

    public void setLensInfoAvailable (final boolean available)
      {
        if (available && !containsTag(LENS_INFO))
          {
            setLensInfo(null);
          }
        else if (!available)
          {
            removeTag(LENS_INFO);
          }
      }

    public Rational[] getLensInfo()
      {
        return (Rational[])getObject(LENS_INFO);
      }

    public void setLensInfo (final Rational[] lensInfo)
      {
        setObject(LENS_INFO, lensInfo);
      }

    public boolean isChromaBlurRadiusAvailable()
      {
        return containsTag(CHROMA_BLUR_RADIUS);
      }

    public void setChromaBlurRadiusAvailable (final boolean available)
      {
        if (available && !containsTag(CHROMA_BLUR_RADIUS))
          {
            setChromaBlurRadius(null);
          }
        else if (!available)
          {
            removeTag(CHROMA_BLUR_RADIUS);
          }
      }

    public Rational getChromaBlurRadius()
      {
        return (Rational)getObject(CHROMA_BLUR_RADIUS);
      }

    public void setChromaBlurRadius (final Rational chromaBlurRadius)
      {
        setObject(CHROMA_BLUR_RADIUS, chromaBlurRadius);
      }

    public boolean isAntiAliasStrengthAvailable()
      {
        return containsTag(ANTI_ALIAS_STRENGTH);
      }

    public void setAntiAliasStrengthAvailable (final boolean available)
      {
        if (available && !containsTag(ANTI_ALIAS_STRENGTH))
          {
            setAntiAliasStrength(null);
          }
        else if (!available)
          {
            removeTag(ANTI_ALIAS_STRENGTH);
          }
      }

    public Rational getAntiAliasStrength()
      {
        return (Rational)getObject(ANTI_ALIAS_STRENGTH);
      }

    public void setAntiAliasStrength (final Rational antiAliasStrength)
      {
        setObject(ANTI_ALIAS_STRENGTH, antiAliasStrength);
      }

    public boolean isDNGPrivateDataAvailable()
      {
        return containsTag(DNG_PRIVATE_DATA);
      }

    public void setDNGPrivateDataAvailable (final boolean available)
      {
        if (available && !containsTag(DNG_PRIVATE_DATA))
          {
            setDNGPrivateData(null);
          }
        else if (!available)
          {
            removeTag(DNG_PRIVATE_DATA);
          }
      }

    public byte[] getDNGPrivateData()
      {
        return (byte[])getObject(DNG_PRIVATE_DATA);
      }

    public void setDNGPrivateData (final byte[] dNGPrivateData)
      {
        setObject(DNG_PRIVATE_DATA, dNGPrivateData);
      }

    public boolean isMakerNoteSafetyAvailable()
      {
        return containsTag(MAKER_NOTE_SAFETY);
      }

    public void setMakerNoteSafetyAvailable (final boolean available)
      {
        if (available && !containsTag(MAKER_NOTE_SAFETY))
          {
            setMakerNoteSafety(null);
          }
        else if (!available)
          {
            removeTag(MAKER_NOTE_SAFETY);
          }
      }

    public Integer getMakerNoteSafety()
      {
        return (Integer)getObject(MAKER_NOTE_SAFETY);
      }

    public void setMakerNoteSafety (final Integer makerNoteSafety)
      {
        setObject(MAKER_NOTE_SAFETY, makerNoteSafety);
      }

    public boolean isShadowScaleAvailable()
      {
        return containsTag(SHADOW_SCALE);
      }

    public void setShadowScaleAvailable (final boolean available)
      {
        if (available && !containsTag(SHADOW_SCALE))
          {
            setShadowScale(null);
          }
        else if (!available)
          {
            removeTag(SHADOW_SCALE);
          }
      }

    public Rational getShadowScale()
      {
        return (Rational)getObject(SHADOW_SCALE);
      }

    public void setShadowScale (final Rational shadowScale)
      {
        setObject(SHADOW_SCALE, shadowScale);
      }

    public boolean isRawDataUniqueIDAvailable()
      {
        return containsTag(RAW_DATA_UNIQUE_ID);
      }

    public void setRawDataUniqueIDAvailable (final boolean available)
      {
        if (available && !containsTag(RAW_DATA_UNIQUE_ID))
          {
            setRawDataUniqueID(null);
          }
        else if (!available)
          {
            removeTag(RAW_DATA_UNIQUE_ID);
          }
      }

    public byte[] getRawDataUniqueID()
      {
        return (byte[])getObject(RAW_DATA_UNIQUE_ID);
      }

    public void setRawDataUniqueID (final byte[] rawDataUniqueID)
      {
        setObject(RAW_DATA_UNIQUE_ID, rawDataUniqueID);
      }

    public boolean isOriginalRawFileNameAvailable()
      {
        return containsTag(ORIGINAL_RAW_FILE_NAME);
      }

    public void setOriginalRawFileNameAvailable (final boolean available)
      {
        if (available && !containsTag(ORIGINAL_RAW_FILE_NAME))
          {
            setOriginalRawFileName(null);
          }
        else if (!available)
          {
            removeTag(ORIGINAL_RAW_FILE_NAME);
          }
      }

    public String getOriginalRawFileName()
      {
        return (String)getObject(ORIGINAL_RAW_FILE_NAME);
      }

    public void setOriginalRawFileName (final String originalRawFileName)
      {
        setObject(ORIGINAL_RAW_FILE_NAME, originalRawFileName);
      }

    public boolean isOriginalRawFileDataAvailable()
      {
        return containsTag(ORIGINAL_RAW_FILE_DATA);
      }

    public void setOriginalRawFileDataAvailable (final boolean available)
      {
        if (available && !containsTag(ORIGINAL_RAW_FILE_DATA))
          {
            setOriginalRawFileData(null);
          }
        else if (!available)
          {
            removeTag(ORIGINAL_RAW_FILE_DATA);
          }
      }

    public byte[] getOriginalRawFileData()
      {
        return (byte[])getObject(ORIGINAL_RAW_FILE_DATA);
      }

    public void setOriginalRawFileData (final byte[] originalRawFileData)
      {
        setObject(ORIGINAL_RAW_FILE_DATA, originalRawFileData);
      }

    public boolean isActiveAreaAvailable()
      {
        return containsTag(ACTIVE_AREA);
      }

    public void setActiveAreaAvailable (final boolean available)
      {
        if (available && !containsTag(ACTIVE_AREA))
          {
            setActiveArea(null);
          }
        else if (!available)
          {
            removeTag(ACTIVE_AREA);
          }
      }

    public int[] getActiveArea()
      {
        return (int[])getObject(ACTIVE_AREA);
      }

    public void setActiveArea (final int[] activeArea)
      {
        setObject(ACTIVE_AREA, activeArea);
      }

    public boolean isMaskedAreasAvailable()
      {
        return containsTag(MASKED_AREAS);
      }

    public void setMaskedAreasAvailable (final boolean available)
      {
        if (available && !containsTag(MASKED_AREAS))
          {
            setMaskedAreas(null);
          }
        else if (!available)
          {
            removeTag(MASKED_AREAS);
          }
      }

    public int[] getMaskedAreas()
      {
        return (int[])getObject(MASKED_AREAS);
      }

    public void setMaskedAreas (final int[] maskedAreas)
      {
        setObject(MASKED_AREAS, maskedAreas);
      }

    public boolean isAsShotICCProfileAvailable()
      {
        return containsTag(AS_SHOT_ICC_PROFILE);
      }

    public void setAsShotICCProfileAvailable (final boolean available)
      {
        if (available && !containsTag(AS_SHOT_ICC_PROFILE))
          {
            setAsShotICCProfile(null);
          }
        else if (!available)
          {
            removeTag(AS_SHOT_ICC_PROFILE);
          }
      }

    public byte[] getAsShotICCProfile()
      {
        return (byte[])getObject(AS_SHOT_ICC_PROFILE);
      }

    public void setAsShotICCProfile (final byte[] asShotICCProfile)
      {
        setObject(AS_SHOT_ICC_PROFILE, asShotICCProfile);
      }

    public boolean isAsShotPreProfileMatrixAvailable()
      {
        return containsTag(AS_SHOT_PRE_PROFILE_MATRIX);
      }

    public void setAsShotPreProfileMatrixAvailable (final boolean available)
      {
        if (available && !containsTag(AS_SHOT_PRE_PROFILE_MATRIX))
          {
            setAsShotPreProfileMatrix(null);
          }
        else if (!available)
          {
            removeTag(AS_SHOT_PRE_PROFILE_MATRIX);
          }
      }

    public Rational[] getAsShotPreProfileMatrix()
      {
        return (Rational[])getObject(AS_SHOT_PRE_PROFILE_MATRIX);
      }

    public void setAsShotPreProfileMatrix (final Rational[] asShotPreProfileMatrix)
      {
        setObject(AS_SHOT_PRE_PROFILE_MATRIX, asShotPreProfileMatrix);
      }

    public boolean isCurrentICCProfileAvailable()
      {
        return containsTag(CURRENT_ICC_PROFILE);
      }

    public void setCurrentICCProfileAvailable (final boolean available)
      {
        if (available && !containsTag(CURRENT_ICC_PROFILE))
          {
            setCurrentICCProfile(null);
          }
        else if (!available)
          {
            removeTag(CURRENT_ICC_PROFILE);
          }
      }

    public byte[] getCurrentICCProfile()
      {
        return (byte[])getObject(CURRENT_ICC_PROFILE);
      }

    public void setCurrentICCProfile (final byte[] currentICCProfile)
      {
        setObject(CURRENT_ICC_PROFILE, currentICCProfile);
      }

    public boolean isCurrentPreProfileMatrixAvailable()
      {
        return containsTag(CURRENT_PRE_PROFILE_MATRIX);
      }

    public void setCurrentPreProfileMatrixAvailable (final boolean available)
      {
        if (available && !containsTag(CURRENT_PRE_PROFILE_MATRIX))
          {
            setCurrentPreProfileMatrix(null);
          }
        else if (!available)
          {
            removeTag(CURRENT_PRE_PROFILE_MATRIX);
          }
      }

    public Rational[] getCurrentPreProfileMatrix()
      {
        return (Rational[])getObject(CURRENT_PRE_PROFILE_MATRIX);
      }

    public void setCurrentPreProfileMatrix (final Rational[] currentPreProfileMatrix)
      {
        setObject(CURRENT_PRE_PROFILE_MATRIX, currentPreProfileMatrix);
      }

    public boolean isAvailable()
      {
        return isNewSubFileTypeAvailable()
             | isSubFileTypeAvailable()
             | isImageWidthAvailable()
             | isImageLengthAvailable()
             | isBitsPerSampleAvailable()
             | isCompressionAvailable()
             | isPhotometricInterpretationAvailable()
             | isThresholdingAvailable()
             | isCellWidthAvailable()
             | isCellLengthAvailable()
             | isFillOrderAvailable()
             | isDocumentNameAvailable()
             | isImageDescriptionAvailable()
             | isMakeAvailable()
             | isModelAvailable()
             | isStripOffsetsAvailable()
             | isOrientationAvailable()
             | isSamplesPerPixelAvailable()
             | isRowsPerStripAvailable()
             | isStripByteCountsAvailable()
             | isMinSampleValueAvailable()
             | isMaxSampleValueAvailable()
             | isXResolutionAvailable()
             | isYResolutionAvailable()
             | isPlanarConfigurationAvailable()
             | isPageNameAvailable()
             | isXPositionAvailable()
             | isYPositionAvailable()
             | isFreeOffsetsAvailable()
             | isFreeByteCountsAvailable()
             | isGrayResponseUnitAvailable()
             | isGrayResponseCurveAvailable()
             | isGroup3OptionsAvailable()
             | isGroup4OptionsAvailable()
             | isResolutionUnitAvailable()
             | isPageNumberAvailable()
             | isColorResponseUnitAvailable()
             | isTransferFunctionAvailable()
             | isSoftwareAvailable()
             | isDateTimeAvailable()
             | isArtistAvailable()
             | isHostComputerAvailable()
             | isPredictorAvailable()
             | isWhitePointAvailable()
             | isPrimaryChromaticitiesAvailable()
             | isTileWidthAvailable()
             | isTileLengthAvailable()
             | isTileOffsetsAvailable()
             | isTileByteCountsAvailable()
             | isBadFaxLinesAvailable()
             | isCleanFaxDataAvailable()
             | isConsecutiveBadFaxLinesAvailable()
             | isSubIFDsAvailable()
             | isInkSetAvailable()
             | isInkNamesAvailable()
             | isNumberOfInksAvailable()
             | isDotRangeAvailable()
             | isTargetPrinterAvailable()
             | isExtraSamplesAvailable()
             | isSampleFormatAvailable()
             | isTransferRangeAvailable()
             | isClipPathAvailable()
             | isXClipPathUnitsAvailable()
             | isYClipPathUnitsAvailable()
             | isIndexedAvailable()
             | isJPEGTablesAvailable()
             | isOPIProxyAvailable()
             | isJPEGProcAvailable()
             | isJPEGInterchangeFormatAvailable()
             | isJPEGInterchangeFormatLengthAvailable()
             | isJPEGRestartIntervalAvailable()
             | isJPEGLosslessPredictorsAvailable()
             | isJPEGPointTransformsAvailable()
             | isJPEGQTablesAvailable()
             | isJPEGDCTablesAvailable()
             | isJPEGACTablesAvailable()
             | isYCbCrCoefficientsAvailable()
             | isYCbCrSubsamplingAvailable()
             | isYCbCrPositioningAvailable()
             | isReferenceBlackWhiteAvailable()
             | isXMPAvailable()
             | isImageIDAvailable()
             | isCFARepeatPatternDimAvailable()
             | isCFAPatternAvailable()
             | isBatteryLevelAvailable()
             | isCopyrightAvailable()
             | isExposureTimeAvailable()
             | isFNumberAvailable()
             | isIPTCNAAAvailable()
             | isModelPixelScaleTagAvailable()
             | isIntergraphMatrixTagAvailable()
             | isModelTiepointTagAvailable()
             | isSiteAvailable()
             | isColorSequenceAvailable()
             | isIT8HeaderAvailable()
             | isRasterPaddingAvailable()
             | isBitsPerRunLengthAvailable()
             | isBitsPerExtendedRunLengthAvailable()
             | isColorTableAvailable()
             | isImageColorIndicatorAvailable()
             | isBackgroundColorIndicatorAvailable()
             | isImageColorValueAvailable()
             | isBackgroundColorValueAvailable()
             | isPixelIntensityRangeAvailable()
             | isTransparencyIndicatorAvailable()
             | isColorCharacterizationAvailable()
             | isHCUsageAvailable()
             | isModelTransformationTagAvailable()
             | isPhotoshopImageResourcesAvailable()
             | isExifIFDPointerAvailable()
             | isInterColourProfileAvailable()
             | isGeoKeyDirectoryTagAvailable()
             | isGeoDoubleParamsTagAvailable()
             | isGeoAsciiParamsTagAvailable()
             | isExposureProgramAvailable()
             | isSpectralSensitivityAvailable()
             | isGPSInfoIFDPointerAvailable()
             | isISOSpeedRatingsAvailable()
             | isOECFAvailable()
             | isInterlaceAvailable()
             | isTimeZoneOffsetAvailable()
             | isSelfTimerModeAvailable()
             | isEXIFVersionAvailable()
             | isDateTimeOriginalAvailable()
             | isDateTimeDigitizedAvailable()
             | isComponentConfigurationAvailable()
             | isCompressedBitsPerPixelAvailable()
             | isShutterSpeedValueAvailable()
             | isApertureValueAvailable()
             | isBrightnessValueAvailable()
             | isExposureBiasValueAvailable()
             | isMaxApertureValueAvailable()
             | isSubjectDistanceAvailable()
             | isMeteringModeAvailable()
             | isLightSourceAvailable()
             | isFlashAvailable()
             | isFocalLengthAvailable()
             | isFlashEnergy2Available()
             | isSpatialFrequencyResponse2Available()
             | isNoiseAvailable()
             | isFocalPlaneXResolution2Available()
             | isFocalPlaneYResolution2Available()
             | isFocalPlaneResolutionUnit2Available()
             | isImageNumberAvailable()
             | isSecurityClassificationAvailable()
             | isImageHistoryAvailable()
             | isSubjectAreaAvailable()
             | isExposureIndex2Available()
             | isTIFF_EPStandardIDAvailable()
             | isSensingMethod2Available()
             | isMakerNoteAvailable()
             | isUserCommentAvailable()
             | isSubsecTimeAvailable()
             | isSubsecTimeOriginalAvailable()
             | isSubsecTimeDigitizedAvailable()
             | isImageSourceDataAvailable()
             | isFlashPixVersionAvailable()
             | isColorSpaceAvailable()
             | isPixelXDimensionAvailable()
             | isPixelYDimensionAvailable()
             | isRelatedSoundFileAvailable()
             | isInteroperabilityIFDAvailable()
             | isFlashEnergyAvailable()
             | isSpatialFrequencyResponseAvailable()
             | isFocalPlaneXResolutionAvailable()
             | isFocalPlaneYResolutionAvailable()
             | isFocalPlaneResolutionUnitAvailable()
             | isSubjectLocationAvailable()
             | isExposureIndexAvailable()
             | isSensingMethodAvailable()
             | isFileSourceAvailable()
             | isSceneTypeAvailable()
             | isEXIFCFAPatternAvailable()
             | isCustomRenderedAvailable()
             | isExposureModeAvailable()
             | isWhiteBalanceAvailable()
             | isDigitalZoomRatioAvailable()
             | isFocalLength35mmFilmAvailable()
             | isSceneCaptureTypeAvailable()
             | isGainControlAvailable()
             | isContrastAvailable()
             | isSaturationAvailable()
             | isSharpnessAvailable()
             | isDeviceSettingDescriptionAvailable()
             | isSubjectDistanceRangeAvailable()
             | isImageUniqueIDAvailable()
             | isPhotoshopAnnotationsAvailable()
             | isThumbnailAvailable()
             | isDNGVersionAvailable()
             | isDNGBackwardVersionAvailable()
             | isUniqueCameraModelAvailable()
             | isLocalizedCameraModelAvailable()
             | isCFAPlaneColorAvailable()
             | isCFALayoutAvailable()
             | isLinearizationTableAvailable()
             | isBlackLevelRepeatDimAvailable()
             | isBlackLevelAvailable()
             | isBlackLevelDeltaHAvailable()
             | isBlackLevelDeltaVAvailable()
             | isWhiteLevelAvailable()
             | isDefaultScaleAvailable()
             | isBestQualityScaleAvailable()
             | isDefaultCropOriginAvailable()
             | isDefaultCropSizeAvailable()
             | isCalibrationIlluminant1Available()
             | isCalibrationIlluminant2Available()
             | isColorMatrix1Available()
             | isColorMatrix2Available()
             | isCameraCalibration1Available()
             | isCameraCalibration2Available()
             | isReductionMatrix1Available()
             | isReductionMatrix2Available()
             | isAnalogBalanceAvailable()
             | isAsShotNeutralAvailable()
             | isAsShotWhiteXYAvailable()
             | isBaselineExposureAvailable()
             | isBaselineNoiseAvailable()
             | isBaselineSharpnessAvailable()
             | isBayerGreenSplitAvailable()
             | isLinearResponseLimitAvailable()
             | isCameraSerialNumberAvailable()
             | isLensInfoAvailable()
             | isChromaBlurRadiusAvailable()
             | isAntiAliasStrengthAvailable()
             | isDNGPrivateDataAvailable()
             | isMakerNoteSafetyAvailable()
             | isShadowScaleAvailable()
             | isRawDataUniqueIDAvailable()
             | isOriginalRawFileNameAvailable()
             | isOriginalRawFileDataAvailable()
             | isActiveAreaAvailable()
             | isMaskedAreasAvailable()
             | isAsShotICCProfileAvailable()
             | isAsShotPreProfileMatrixAvailable()
             | isCurrentICCProfileAvailable()
             | isCurrentPreProfileMatrixAvailable()
;
      }
    @Override
    public String getTagName (int tag)
      {
        return (String)descriptionMapByTag.get(tag);
      }
    static
      {
        descriptionMapByTag.put(254, "New SubFile Type");
        descriptionMapByTag.put(255, "Sub FileType");
        descriptionMapByTag.put(256, "Image Width");
        descriptionMapByTag.put(257, "Image Length");
        descriptionMapByTag.put(258, "Bits Per Sample");
        descriptionMapByTag.put(259, "Compression");
        descriptionMapByTag.put(262, "Photometric Interpretation");
        descriptionMapByTag.put(263, "Thresholding");
        descriptionMapByTag.put(264, "Cell Width");
        descriptionMapByTag.put(265, "Cell Length");
        descriptionMapByTag.put(266, "Fill Order");
        descriptionMapByTag.put(269, "Document Name");
        descriptionMapByTag.put(270, "Image Description");
        descriptionMapByTag.put(271, "Make");
        descriptionMapByTag.put(272, "Model");
        descriptionMapByTag.put(273, "Strip Offsets");
        descriptionMapByTag.put(274, "Orientation");
        descriptionMapByTag.put(277, "Samples Per Pixel");
        descriptionMapByTag.put(278, "Rows Per Strip");
        descriptionMapByTag.put(279, "Strip Byte Counts");
        descriptionMapByTag.put(280, "Min Sample Value");
        descriptionMapByTag.put(281, "Max Sample Value");
        descriptionMapByTag.put(282, "X Resolution");
        descriptionMapByTag.put(283, "Y Resolution");
        descriptionMapByTag.put(284, "Planar Configuration");
        descriptionMapByTag.put(285, "Page Name");
        descriptionMapByTag.put(286, "X Position");
        descriptionMapByTag.put(287, "Y Position");
        descriptionMapByTag.put(288, "Free Offsets");
        descriptionMapByTag.put(289, "Free Byte Counts");
        descriptionMapByTag.put(290, "Gray Response Unit");
        descriptionMapByTag.put(291, "Gray Response Curve");
        descriptionMapByTag.put(292, "Group 3 Options");
        descriptionMapByTag.put(293, "Group 4 Options");
        descriptionMapByTag.put(296, "Resolution Unit");
        descriptionMapByTag.put(297, "Page Number");
        descriptionMapByTag.put(300, "Color Response Unit");
        descriptionMapByTag.put(301, "Transfer Function");
        descriptionMapByTag.put(305, "Software");
        descriptionMapByTag.put(306, "Date/Time");
        descriptionMapByTag.put(315, "Artist");
        descriptionMapByTag.put(316, "Host Computer");
        descriptionMapByTag.put(317, "Predictor");
        descriptionMapByTag.put(318, "White Point");
        descriptionMapByTag.put(319, "Primary Chromaticities");
        descriptionMapByTag.put(322, "Tile Width");
        descriptionMapByTag.put(323, "Tile Length");
        descriptionMapByTag.put(324, "Tile Offsets");
        descriptionMapByTag.put(325, "Tile Byte Counts");
        descriptionMapByTag.put(326, "Bad Fax Lines");
        descriptionMapByTag.put(327, "Clean Fax Data");
        descriptionMapByTag.put(328, "Consecutive Bad Fax Lines");
        descriptionMapByTag.put(330, "Sub IFDs");
        descriptionMapByTag.put(332, "Ink Set");
        descriptionMapByTag.put(333, "Ink Names");
        descriptionMapByTag.put(334, "Number Of Inks");
        descriptionMapByTag.put(336, "Dot Range");
        descriptionMapByTag.put(337, "Target Printer");
        descriptionMapByTag.put(338, "Extra Samples");
        descriptionMapByTag.put(339, "Sample Format");
        descriptionMapByTag.put(342, "Transfer Range");
        descriptionMapByTag.put(343, "Clip Path");
        descriptionMapByTag.put(344, "X Clip Path Units");
        descriptionMapByTag.put(345, "Y Clip Path Units");
        descriptionMapByTag.put(346, "Indexed");
        descriptionMapByTag.put(347, "JPEG Tables");
        descriptionMapByTag.put(351, "OPI Proxy");
        descriptionMapByTag.put(512, "JPEG Proc");
        descriptionMapByTag.put(513, "JPEG Interchange Format");
        descriptionMapByTag.put(514, "JPEG Interchange Format Length");
        descriptionMapByTag.put(515, "JPEG Restart Interval");
        descriptionMapByTag.put(517, "JPEG Lossless Predictors");
        descriptionMapByTag.put(518, "JPEG Point Transforms");
        descriptionMapByTag.put(519, "JPEG Q Tables");
        descriptionMapByTag.put(520, "JPEG DC Tables");
        descriptionMapByTag.put(521, "JPEG AC Tables");
        descriptionMapByTag.put(529, "YCbCr Coefficients");
        descriptionMapByTag.put(530, "YCbCr Subsampling");
        descriptionMapByTag.put(531, "YCbCr Positioning");
        descriptionMapByTag.put(532, "Reference Black White");
        descriptionMapByTag.put(700, "XMP");
        descriptionMapByTag.put(32781, "Image ID");
        descriptionMapByTag.put(33421, "CFA Repeat Pattern Dim");
        descriptionMapByTag.put(33422, "CFA Pattern");
        descriptionMapByTag.put(33423, "Battery Level");
        descriptionMapByTag.put(33432, "Copyright");
        descriptionMapByTag.put(33434, "Exposure Time");
        descriptionMapByTag.put(33437, "F Number");
        descriptionMapByTag.put(33723, "IPTC NAA");
        descriptionMapByTag.put(33550, "Model Pixel Scale Tag");
        descriptionMapByTag.put(33920, "Intergraph Matrix Tag");
        descriptionMapByTag.put(33922, "Model Tiepoint Tag");
        descriptionMapByTag.put(34016, "Site");
        descriptionMapByTag.put(34017, "Color Sequence");
        descriptionMapByTag.put(34018, "IT8 Header");
        descriptionMapByTag.put(34019, "Raster Padding");
        descriptionMapByTag.put(34020, "Bits Per Run Length");
        descriptionMapByTag.put(34021, "Bits Per Extended Run Length");
        descriptionMapByTag.put(34022, "Color Table");
        descriptionMapByTag.put(34023, "Image Color Indicator");
        descriptionMapByTag.put(34024, "Background Color Indicator");
        descriptionMapByTag.put(34025, "Image Color Value");
        descriptionMapByTag.put(34026, "Background Color Value");
        descriptionMapByTag.put(34027, "Pixel Intensity Range");
        descriptionMapByTag.put(34028, "Transparency Indicator");
        descriptionMapByTag.put(34029, "Color Characterization");
        descriptionMapByTag.put(34030, "HC Usage");
        descriptionMapByTag.put(34264, "Model Transformation Tag");
        descriptionMapByTag.put(34377, "Photoshop Image Resources");
        descriptionMapByTag.put(34665, "Exif IFD Pointer");
        descriptionMapByTag.put(34675, "Inter Colour Profile");
        descriptionMapByTag.put(34735, "Geo Key DirectoryTag");
        descriptionMapByTag.put(34736, "Geo Double Params Tag");
        descriptionMapByTag.put(34737, "Geo Ascii Params Tag");
        descriptionMapByTag.put(34850, "Exposure Program");
        descriptionMapByTag.put(34852, "Spectral Sensitivity");
        descriptionMapByTag.put(34853, "GPS Info IFD Pointer");
        descriptionMapByTag.put(34855, "ISO Speed Ratings");
        descriptionMapByTag.put(34856, "OECF");
        descriptionMapByTag.put(34857, "Interlace");
        descriptionMapByTag.put(34858, "Time Zone Offset");
        descriptionMapByTag.put(34859, "Self Timer Mode");
        descriptionMapByTag.put(36864, "EXIF Version");
        descriptionMapByTag.put(36867, "Date/Time Original");
        descriptionMapByTag.put(36868, "Date/Time Digitized");
        descriptionMapByTag.put(37121, "Component Configuration");
        descriptionMapByTag.put(37122, "Compressed Bits Per Pixel");
        descriptionMapByTag.put(37377, "Shutter SpeedValue");
        descriptionMapByTag.put(37378, "Aperture Value");
        descriptionMapByTag.put(37379, "Brightness Value");
        descriptionMapByTag.put(37380, "Exposure Bias Value");
        descriptionMapByTag.put(37381, "Max Aperture Value");
        descriptionMapByTag.put(37382, "Subject Distance");
        descriptionMapByTag.put(37383, "Metering Mode");
        descriptionMapByTag.put(37384, "Light Source");
        descriptionMapByTag.put(37385, "Flash");
        descriptionMapByTag.put(37386, "Focal Length");
        descriptionMapByTag.put(37387, "Flash Energy2");
        descriptionMapByTag.put(37388, "Spatial FrequencyResponse2");
        descriptionMapByTag.put(37389, "Noise");
        descriptionMapByTag.put(37390, "Focal PlaneXResolution2");
        descriptionMapByTag.put(37391, "Focal PlaneYResolution2");
        descriptionMapByTag.put(37392, "Focal PlaneResolutionUnit2");
        descriptionMapByTag.put(37393, "Image Number");
        descriptionMapByTag.put(37394, "Security Classification");
        descriptionMapByTag.put(37395, "Image History");
        descriptionMapByTag.put(37396, "Subject Area");
        descriptionMapByTag.put(37397, "Exposure Index 2");
        descriptionMapByTag.put(37398, "TIFF_EP Standard ID");
        descriptionMapByTag.put(37399, "Sensing Method 2");
        descriptionMapByTag.put(37500, "Maker Note");
        descriptionMapByTag.put(37510, "User Comment");
        descriptionMapByTag.put(37520, "Subsec Time");
        descriptionMapByTag.put(37521, "Subsec Time Original");
        descriptionMapByTag.put(37522, "Subsec Time Digitized");
        descriptionMapByTag.put(37724, "Image Source Data");
        descriptionMapByTag.put(40960, "FlashPix Version");
        descriptionMapByTag.put(40961, "Color Space");
        descriptionMapByTag.put(40962, "Pixel X Dimension");
        descriptionMapByTag.put(40963, "Pixel Y Dimension");
        descriptionMapByTag.put(40964, "Related Sound File");
        descriptionMapByTag.put(40965, "Interoperability IFD");
        descriptionMapByTag.put(41483, "Flash Energy");
        descriptionMapByTag.put(41484, "Spatial Frequency Response");
        descriptionMapByTag.put(41486, "Focal Plane X Resolution");
        descriptionMapByTag.put(41487, "Focal Plane Y Resolution");
        descriptionMapByTag.put(41488, "Focal Plane ResolutionUnit");
        descriptionMapByTag.put(41492, "Subject Location");
        descriptionMapByTag.put(41493, "Exposure Index");
        descriptionMapByTag.put(41495, "Sensing Method");
        descriptionMapByTag.put(41728, "File Source");
        descriptionMapByTag.put(41729, "Scene Type");
        descriptionMapByTag.put(41730, "EXIF CFA Pattern");
        descriptionMapByTag.put(41985, "Custom Rendered");
        descriptionMapByTag.put(41986, "Exposure Mode");
        descriptionMapByTag.put(41987, "White Balance");
        descriptionMapByTag.put(41988, "Digital Zoom Ratio");
        descriptionMapByTag.put(41989, "Focal Length 35mm Film");
        descriptionMapByTag.put(41990, "Scene Capture Type");
        descriptionMapByTag.put(41991, "Gain Control");
        descriptionMapByTag.put(41992, "Contrast");
        descriptionMapByTag.put(41993, "Saturation");
        descriptionMapByTag.put(41994, "Sharpness");
        descriptionMapByTag.put(41995, "Device Setting Description");
        descriptionMapByTag.put(41996, "Subject Distance Range");
        descriptionMapByTag.put(42016, "Image Unique ID");
        descriptionMapByTag.put(50255, "Photoshop Annotations");
        descriptionMapByTag.put(61441, "Thumbnail");
        descriptionMapByTag.put(50706, "DNG Version");
        descriptionMapByTag.put(50707, "DNG Backward Version");
        descriptionMapByTag.put(50708, "Unique Camera Model");
        descriptionMapByTag.put(50709, "Localized Camera Model");
        descriptionMapByTag.put(50710, "CFA Plane Color");
        descriptionMapByTag.put(50711, "CFA Layout");
        descriptionMapByTag.put(50712, "Linearization Table");
        descriptionMapByTag.put(50713, "Black Level Repeat Dim");
        descriptionMapByTag.put(50714, "Black Level");
        descriptionMapByTag.put(50715, "Black Level Delta H");
        descriptionMapByTag.put(50716, "Black Level Delta V");
        descriptionMapByTag.put(50717, "White Level");
        descriptionMapByTag.put(50718, "Default Scale");
        descriptionMapByTag.put(50780, "Best Quality Scale");
        descriptionMapByTag.put(50719, "Default Crop Origin");
        descriptionMapByTag.put(50720, "Default Crop Size");
        descriptionMapByTag.put(50778, "Calibration Illuminant 1");
        descriptionMapByTag.put(50779, "Calibration Illuminant 2");
        descriptionMapByTag.put(50721, "Color Matrix 1");
        descriptionMapByTag.put(50722, "Color Matrix 2");
        descriptionMapByTag.put(50723, "Camera Calibration 1");
        descriptionMapByTag.put(50724, "Camera Calibration 2");
        descriptionMapByTag.put(50725, "Reduction Matrix 1");
        descriptionMapByTag.put(50726, "Reduction Matrix 2");
        descriptionMapByTag.put(50727, "Analog Balance");
        descriptionMapByTag.put(50728, "As Shot Neutral");
        descriptionMapByTag.put(50729, "As Shot White XY");
        descriptionMapByTag.put(50730, "Baseline Exposure");
        descriptionMapByTag.put(50731, "Baseline Noise");
        descriptionMapByTag.put(50732, "Baseline Sharpness");
        descriptionMapByTag.put(50733, "Bayer Green Split");
        descriptionMapByTag.put(50734, "Linear Response Limit");
        descriptionMapByTag.put(50735, "Camera Serial Number");
        descriptionMapByTag.put(50736, "Lens Info");
        descriptionMapByTag.put(50737, "Chroma Blur Radius");
        descriptionMapByTag.put(50738, "Anti Alias Strength");
        descriptionMapByTag.put(50740, "DNG Private Data");
        descriptionMapByTag.put(50741, "Maker Note Safety");
        descriptionMapByTag.put(50739, "Shadow Scale");
        descriptionMapByTag.put(50781, "Raw Data Unique ID");
        descriptionMapByTag.put(50827, "Original Raw File Name");
        descriptionMapByTag.put(50828, "Original Raw File Data");
        descriptionMapByTag.put(50829, "Active Area");
        descriptionMapByTag.put(50830, "Masked Areas");
        descriptionMapByTag.put(50831, "As Shot ICC Profile");
        descriptionMapByTag.put(50832, "As Shot Pre Profile Matrix");
        descriptionMapByTag.put(50833, "Current ICC Profile");
        descriptionMapByTag.put(50834, "Current Pre Profile Matrix");

      }
        public final static int NEW_SUBFILE_TYPE = 254;
        public final static int SUB_FILETYPE = 255;
        public final static int IMAGE_WIDTH = 256;
        public final static int IMAGE_LENGTH = 257;
        public final static int BITS_PER_SAMPLE = 258;
        public final static int COMPRESSION = 259;
        public final static int PHOTOMETRIC_INTERPRETATION = 262;
        public final static int THRESHOLDING = 263;
        public final static int CELL_WIDTH = 264;
        public final static int CELL_LENGTH = 265;
        public final static int FILL_ORDER = 266;
        public final static int DOCUMENT_NAME = 269;
        public final static int IMAGE_DESCRIPTION = 270;
        public final static int MAKE = 271;
        public final static int MODEL = 272;
        public final static int STRIP_OFFSETS = 273;
        public final static int ORIENTATION = 274;
        public final static int SAMPLES_PER_PIXEL = 277;
        public final static int ROWS_PER_STRIP = 278;
        public final static int STRIP_BYTE_COUNTS = 279;
        public final static int MIN_SAMPLE_VALUE = 280;
        public final static int MAX_SAMPLE_VALUE = 281;
        public final static int X_RESOLUTION = 282;
        public final static int Y_RESOLUTION = 283;
        public final static int PLANAR_CONFIGURATION = 284;
        public final static int PAGE_NAME = 285;
        public final static int X_POSITION = 286;
        public final static int Y_POSITION = 287;
        public final static int FREE_OFFSETS = 288;
        public final static int FREE_BYTE_COUNTS = 289;
        public final static int GRAY_RESPONSE_UNIT = 290;
        public final static int GRAY_RESPONSE_CURVE = 291;
        public final static int GROUP_3_OPTIONS = 292;
        public final static int GROUP_4_OPTIONS = 293;
        public final static int RESOLUTION_UNIT = 296;
        public final static int PAGE_NUMBER = 297;
        public final static int COLOR_RESPONSE_UNIT = 300;
        public final static int TRANSFER_FUNCTION = 301;
        public final static int SOFTWARE = 305;
        public final static int DATETIME = 306;
        public final static int ARTIST = 315;
        public final static int HOST_COMPUTER = 316;
        public final static int PREDICTOR = 317;
        public final static int WHITE_POINT = 318;
        public final static int PRIMARY_CHROMATICITIES = 319;
        public final static int TILE_WIDTH = 322;
        public final static int TILE_LENGTH = 323;
        public final static int TILE_OFFSETS = 324;
        public final static int TILE_BYTE_COUNTS = 325;
        public final static int BAD_FAX_LINES = 326;
        public final static int CLEAN_FAX_DATA = 327;
        public final static int CONSECUTIVE_BAD_FAX_LINES = 328;
        public final static int SUB_IFDS = 330;
        public final static int INK_SET = 332;
        public final static int INK_NAMES = 333;
        public final static int NUMBER_OF_INKS = 334;
        public final static int DOT_RANGE = 336;
        public final static int TARGET_PRINTER = 337;
        public final static int EXTRA_SAMPLES = 338;
        public final static int SAMPLE_FORMAT = 339;
        public final static int TRANSFER_RANGE = 342;
        public final static int CLIP_PATH = 343;
        public final static int X_CLIP_PATH_UNITS = 344;
        public final static int Y_CLIP_PATH_UNITS = 345;
        public final static int INDEXED = 346;
        public final static int JPEG_TABLES = 347;
        public final static int OPI_PROXY = 351;
        public final static int JPEG_PROC = 512;
        public final static int JPEG_INTERCHANGE_FORMAT = 513;
        public final static int JPEG_INTERCHANGE_FORMAT_LENGTH = 514;
        public final static int JPEG_RESTART_INTERVAL = 515;
        public final static int JPEG_LOSSLESS_PREDICTORS = 517;
        public final static int JPEG_POINT_TRANSFORMS = 518;
        public final static int JPEG_Q_TABLES = 519;
        public final static int JPEG_DC_TABLES = 520;
        public final static int JPEG_AC_TABLES = 521;
        public final static int YCBCR_COEFFICIENTS = 529;
        public final static int YCBCR_SUBSAMPLING = 530;
        public final static int YCBCR_POSITIONING = 531;
        public final static int REFERENCE_BLACK_WHITE = 532;
        public final static int XMP = 700;
        public final static int IMAGE_ID = 32781;
        public final static int CFA_REPEAT_PATTERN_DIM = 33421;
        public final static int CFA_PATTERN = 33422;
        public final static int BATTERY_LEVEL = 33423;
        public final static int COPYRIGHT = 33432;
        public final static int EXPOSURE_TIME = 33434;
        public final static int F_NUMBER = 33437;
        public final static int IPTC_NAA = 33723;
        public final static int MODEL_PIXEL_SCALE_TAG = 33550;
        public final static int INTERGRAPH_MATRIX_TAG = 33920;
        public final static int MODEL_TIEPOINT_TAG = 33922;
        public final static int SITE = 34016;
        public final static int COLOR_SEQUENCE = 34017;
        public final static int IT8_HEADER = 34018;
        public final static int RASTER_PADDING = 34019;
        public final static int BITS_PER_RUN_LENGTH = 34020;
        public final static int BITS_PER_EXTENDED_RUN_LENGTH = 34021;
        public final static int COLOR_TABLE = 34022;
        public final static int IMAGE_COLOR_INDICATOR = 34023;
        public final static int BACKGROUND_COLOR_INDICATOR = 34024;
        public final static int IMAGE_COLOR_VALUE = 34025;
        public final static int BACKGROUND_COLOR_VALUE = 34026;
        public final static int PIXEL_INTENSITY_RANGE = 34027;
        public final static int TRANSPARENCY_INDICATOR = 34028;
        public final static int COLOR_CHARACTERIZATION = 34029;
        public final static int HC_USAGE = 34030;
        public final static int MODEL_TRANSFORMATION_TAG = 34264;
        public final static int PHOTOSHOP_IMAGE_RESOURCES = 34377;
        public final static int EXIF_IFD_POINTER = 34665;
        public final static int INTER_COLOUR_PROFILE = 34675;
        public final static int GEO_KEY_DIRECTORYTAG = 34735;
        public final static int GEO_DOUBLE_PARAMS_TAG = 34736;
        public final static int GEO_ASCII_PARAMS_TAG = 34737;
        public final static int EXPOSURE_PROGRAM = 34850;
        public final static int SPECTRAL_SENSITIVITY = 34852;
        public final static int GPS_INFO_IFD_POINTER = 34853;
        public final static int ISO_SPEED_RATINGS = 34855;
        public final static int OECF = 34856;
        public final static int INTERLACE = 34857;
        public final static int TIME_ZONE_OFFSET = 34858;
        public final static int SELF_TIMER_MODE = 34859;
        public final static int EXIF_VERSION = 36864;
        public final static int DATETIME_ORIGINAL = 36867;
        public final static int DATETIME_DIGITIZED = 36868;
        public final static int COMPONENT_CONFIGURATION = 37121;
        public final static int COMPRESSED_BITS_PER_PIXEL = 37122;
        public final static int SHUTTER_SPEEDVALUE = 37377;
        public final static int APERTURE_VALUE = 37378;
        public final static int BRIGHTNESS_VALUE = 37379;
        public final static int EXPOSURE_BIAS_VALUE = 37380;
        public final static int MAX_APERTURE_VALUE = 37381;
        public final static int SUBJECT_DISTANCE = 37382;
        public final static int METERING_MODE = 37383;
        public final static int LIGHT_SOURCE = 37384;
        public final static int FLASH = 37385;
        public final static int FOCAL_LENGTH = 37386;
        public final static int FLASH_ENERGY2 = 37387;
        public final static int SPATIAL_FREQUENCYRESPONSE2 = 37388;
        public final static int NOISE = 37389;
        public final static int FOCAL_PLANEXRESOLUTION2 = 37390;
        public final static int FOCAL_PLANEYRESOLUTION2 = 37391;
        public final static int FOCAL_PLANERESOLUTIONUNIT2 = 37392;
        public final static int IMAGE_NUMBER = 37393;
        public final static int SECURITY_CLASSIFICATION = 37394;
        public final static int IMAGE_HISTORY = 37395;
        public final static int SUBJECT_AREA = 37396;
        public final static int EXPOSURE_INDEX_2 = 37397;
        public final static int TIFF_EP_STANDARD_ID = 37398;
        public final static int SENSING_METHOD_2 = 37399;
        public final static int MAKER_NOTE = 37500;
        public final static int USER_COMMENT = 37510;
        public final static int SUBSEC_TIME = 37520;
        public final static int SUBSEC_TIME_ORIGINAL = 37521;
        public final static int SUBSEC_TIME_DIGITIZED = 37522;
        public final static int IMAGE_SOURCE_DATA = 37724;
        public final static int FLASHPIX_VERSION = 40960;
        public final static int COLOR_SPACE = 40961;
        public final static int PIXEL_X_DIMENSION = 40962;
        public final static int PIXEL_Y_DIMENSION = 40963;
        public final static int RELATED_SOUND_FILE = 40964;
        public final static int INTEROPERABILITY_IFD = 40965;
        public final static int FLASH_ENERGY = 41483;
        public final static int SPATIAL_FREQUENCY_RESPONSE = 41484;
        public final static int FOCAL_PLANE_X_RESOLUTION = 41486;
        public final static int FOCAL_PLANE_Y_RESOLUTION = 41487;
        public final static int FOCAL_PLANE_RESOLUTIONUNIT = 41488;
        public final static int SUBJECT_LOCATION = 41492;
        public final static int EXPOSURE_INDEX = 41493;
        public final static int SENSING_METHOD = 41495;
        public final static int FILE_SOURCE = 41728;
        public final static int SCENE_TYPE = 41729;
        public final static int EXIF_CFA_PATTERN = 41730;
        public final static int CUSTOM_RENDERED = 41985;
        public final static int EXPOSURE_MODE = 41986;
        public final static int WHITE_BALANCE = 41987;
        public final static int DIGITAL_ZOOM_RATIO = 41988;
        public final static int FOCAL_LENGTH_35MM_FILM = 41989;
        public final static int SCENE_CAPTURE_TYPE = 41990;
        public final static int GAIN_CONTROL = 41991;
        public final static int CONTRAST = 41992;
        public final static int SATURATION = 41993;
        public final static int SHARPNESS = 41994;
        public final static int DEVICE_SETTING_DESCRIPTION = 41995;
        public final static int SUBJECT_DISTANCE_RANGE = 41996;
        public final static int IMAGE_UNIQUE_ID = 42016;
        public final static int PHOTOSHOP_ANNOTATIONS = 50255;
        public final static int THUMBNAIL = 61441;
        public final static int DNG_VERSION = 50706;
        public final static int DNG_BACKWARD_VERSION = 50707;
        public final static int UNIQUE_CAMERA_MODEL = 50708;
        public final static int LOCALIZED_CAMERA_MODEL = 50709;
        public final static int CFA_PLANE_COLOR = 50710;
        public final static int CFA_LAYOUT = 50711;
        public final static int LINEARIZATION_TABLE = 50712;
        public final static int BLACK_LEVEL_REPEAT_DIM = 50713;
        public final static int BLACK_LEVEL = 50714;
        public final static int BLACK_LEVEL_DELTA_H = 50715;
        public final static int BLACK_LEVEL_DELTA_V = 50716;
        public final static int WHITE_LEVEL = 50717;
        public final static int DEFAULT_SCALE = 50718;
        public final static int BEST_QUALITY_SCALE = 50780;
        public final static int DEFAULT_CROP_ORIGIN = 50719;
        public final static int DEFAULT_CROP_SIZE = 50720;
        public final static int CALIBRATION_ILLUMINANT_1 = 50778;
        public final static int CALIBRATION_ILLUMINANT_2 = 50779;
        public final static int COLOR_MATRIX_1 = 50721;
        public final static int COLOR_MATRIX_2 = 50722;
        public final static int CAMERA_CALIBRATION_1 = 50723;
        public final static int CAMERA_CALIBRATION_2 = 50724;
        public final static int REDUCTION_MATRIX_1 = 50725;
        public final static int REDUCTION_MATRIX_2 = 50726;
        public final static int ANALOG_BALANCE = 50727;
        public final static int AS_SHOT_NEUTRAL = 50728;
        public final static int AS_SHOT_WHITE_XY = 50729;
        public final static int BASELINE_EXPOSURE = 50730;
        public final static int BASELINE_NOISE = 50731;
        public final static int BASELINE_SHARPNESS = 50732;
        public final static int BAYER_GREEN_SPLIT = 50733;
        public final static int LINEAR_RESPONSE_LIMIT = 50734;
        public final static int CAMERA_SERIAL_NUMBER = 50735;
        public final static int LENS_INFO = 50736;
        public final static int CHROMA_BLUR_RADIUS = 50737;
        public final static int ANTI_ALIAS_STRENGTH = 50738;
        public final static int DNG_PRIVATE_DATA = 50740;
        public final static int MAKER_NOTE_SAFETY = 50741;
        public final static int SHADOW_SCALE = 50739;
        public final static int RAW_DATA_UNIQUE_ID = 50781;
        public final static int ORIGINAL_RAW_FILE_NAME = 50827;
        public final static int ORIGINAL_RAW_FILE_DATA = 50828;
        public final static int ACTIVE_AREA = 50829;
        public final static int MASKED_AREAS = 50830;
        public final static int AS_SHOT_ICC_PROFILE = 50831;
        public final static int AS_SHOT_PRE_PROFILE_MATRIX = 50832;
        public final static int CURRENT_ICC_PROFILE = 50833;
        public final static int CURRENT_PRE_PROFILE_MATRIX = 50834;

  }
